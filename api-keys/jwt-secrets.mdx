---
title: JWT Secrets and Token Security
description: Securing JWT signing secrets and token management
---

## Common Misconfiguration

Weak or exposed JWT secrets allow attackers to forge tokens, bypass authentication, and gain unauthorized access to systems.

### Vulnerable Example

```javascript
// VULNERABLE - Hardcoded JWT secrets
const jwt = require('jsonwebtoken');

// Never hardcode JWT secrets!
const JWT_SECRET = 'my-super-secret-key';  // Weak secret
const REFRESH_SECRET = 'refresh-secret-123';  // Predictable

// Using HS256 with weak secret
function generateToken(userId) {
    return jwt.sign(
        { userId, role: 'admin' },
        JWT_SECRET,
        { expiresIn: '7d' }  // Long expiration
    );
}

// No token validation
function verifyToken(token) {
    try {
        return jwt.verify(token, JWT_SECRET);
    } catch (err) {
        return null;  // Silently fail
    }
}

// Storing sensitive data in JWT
function createInsecureToken(user) {
    return jwt.sign({
        id: user.id,
        email: user.email,
        password: user.password,  // Never include passwords!
        creditCard: user.creditCard,  // Never include sensitive data!
        ssn: user.ssn
    }, JWT_SECRET);
}
```

```python
# VULNERABLE - Flask JWT implementation
from flask import Flask
from flask_jwt_extended import JWTManager, create_access_token
import datetime

app = Flask(__name__)

# Weak and hardcoded secrets
app.config['JWT_SECRET_KEY'] = 'super-secret'  # Never hardcode!
app.config['JWT_ACCESS_TOKEN_EXPIRES'] = datetime.timedelta(days=365)  # Too long!
app.config['JWT_ALGORITHM'] = 'HS256'  # Consider RS256 for better security

jwt = JWTManager(app)

# No refresh token rotation
@app.route('/login', methods=['POST'])
def login():
    # ... authentication logic ...
    access_token = create_access_token(
        identity=user_id,
        additional_claims={'role': 'admin', 'permissions': ['all']}  # Too much info
    )
    return {'token': access_token}

# Using none algorithm (dangerous!)
def decode_token_unsafe(token):
    import jwt
    return jwt.decode(token, options={"verify_signature": False})  # Never do this!
```

## Secure Example

```javascript
// SECURE - Proper JWT implementation
const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const fs = require('fs').promises;

class SecureJWTManager {
    constructor() {
        this.accessTokenSecret = null;
        this.refreshTokenSecret = null;
        this.publicKey = null;
        this.privateKey = null;
        this.initialized = false;
    }
    
    async initialize() {
        // Use RS256 with key pairs for production
        if (process.env.NODE_ENV === 'production') {
            await this.loadRSAKeys();
        } else {
            // Use strong random secrets for development
            this.loadHMACSecrets();
        }
        
        this.initialized = true;
    }
    
    async loadRSAKeys() {
        // Load RSA key pair from secure location
        try {
            this.privateKey = await fs.readFile(process.env.JWT_PRIVATE_KEY_PATH, 'utf8');
            this.publicKey = await fs.readFile(process.env.JWT_PUBLIC_KEY_PATH, 'utf8');
        } catch (error) {
            console.error('Failed to load RSA keys:', error);
            throw new Error('JWT key configuration failed');
        }
    }
    
    loadHMACSecrets() {
        // Load from environment with validation
        const accessSecret = process.env.JWT_ACCESS_SECRET;
        const refreshSecret = process.env.JWT_REFRESH_SECRET;
        
        if (!accessSecret || accessSecret.length < 32) {
            throw new Error('JWT_ACCESS_SECRET must be at least 32 characters');
        }
        
        if (!refreshSecret || refreshSecret.length < 32) {
            throw new Error('JWT_REFRESH_SECRET must be at least 32 characters');
        }
        
        this.accessTokenSecret = accessSecret;
        this.refreshTokenSecret = refreshSecret;
    }
    
    generateTokenPair(userId, userInfo = {}) {
        // Minimal payload - don't include sensitive data
        const payload = {
            sub: userId,
            type: 'access',
            iat: Math.floor(Date.now() / 1000)
        };
        
        // Access token - short lived
        const accessToken = this.signToken(payload, {
            algorithm: this.privateKey ? 'RS256' : 'HS256',
            expiresIn: '15m',  // Short expiration
            issuer: 'api.example.com',
            audience: 'app.example.com'
        });
        
        // Refresh token - longer lived but still limited
        const refreshPayload = {
            sub: userId,
            type: 'refresh',
            iat: Math.floor(Date.now() / 1000),
            family: crypto.randomBytes(16).toString('hex')  // Token family for rotation
        };
        
        const refreshToken = this.signToken(refreshPayload, {
            algorithm: 'HS256',
            expiresIn: '7d',
            issuer: 'api.example.com'
        });
        
        return {
            accessToken,
            refreshToken,
            expiresIn: 900  // 15 minutes in seconds
        };
    }
    
    signToken(payload, options) {
        const secret = options.algorithm === 'RS256' 
            ? this.privateKey 
            : (payload.type === 'refresh' ? this.refreshTokenSecret : this.accessTokenSecret);
            
        return jwt.sign(payload, secret, options);
    }
    
    verifyAccessToken(token) {
        try {
            const secret = this.publicKey || this.accessTokenSecret;
            const decoded = jwt.verify(token, secret, {
                algorithms: this.publicKey ? ['RS256'] : ['HS256'],
                issuer: 'api.example.com',
                audience: 'app.example.com',
                clockTolerance: 30  // 30 seconds clock skew tolerance
            });
            
            // Additional validation
            if (decoded.type !== 'access') {
                throw new Error('Invalid token type');
            }
            
            return decoded;
        } catch (error) {
            // Log for security monitoring
            console.error('Token verification failed:', error.message);
            throw error;
        }
    }
    
    async verifyRefreshToken(token) {
        try {
            const decoded = jwt.verify(token, this.refreshTokenSecret, {
                algorithms: ['HS256'],
                issuer: 'api.example.com'
            });
            
            if (decoded.type !== 'refresh') {
                throw new Error('Invalid token type');
            }
            
            // Check if token family is valid (for rotation detection)
            const isValidFamily = await this.checkTokenFamily(decoded.family);
            if (!isValidFamily) {
                // Possible token reuse - revoke all tokens for this user
                await this.revokeUserTokens(decoded.sub);
                throw new Error('Token reuse detected');
            }
            
            return decoded;
        } catch (error) {
            console.error('Refresh token verification failed:', error.message);
            throw error;
        }
    }
    
    // Token rotation for refresh tokens
    async rotateRefreshToken(oldToken) {
        const decoded = await this.verifyRefreshToken(oldToken);
        
        // Invalidate old token
        await this.invalidateToken(oldToken);
        
        // Generate new token pair
        return this.generateTokenPair(decoded.sub);
    }
    
    // Generate cryptographically secure secret
    static generateSecret(length = 64) {
        return crypto.randomBytes(length).toString('base64');
    }
}

// Express middleware for JWT validation
const jwtMiddleware = (jwtManager) => {
    return async (req, res, next) => {
        const authHeader = req.headers.authorization;
        
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            return res.status(401).json({ error: 'No token provided' });
        }
        
        const token = authHeader.substring(7);
        
        try {
            const decoded = jwtManager.verifyAccessToken(token);
            req.user = decoded;
            
            // Check if token is close to expiration
            const now = Math.floor(Date.now() / 1000);
            if (decoded.exp - now < 300) {  // Less than 5 minutes
                res.setHeader('X-Token-Expiring-Soon', 'true');
            }
            
            next();
        } catch (error) {
            return res.status(401).json({ error: 'Invalid token' });
        }
    };
};

// Kubernetes secret for JWT keys
const k8sSecret = `
apiVersion: v1
kind: Secret
metadata:
  name: jwt-keys
  namespace: production
type: Opaque
data:
  jwt-private-key: LS0tLS1CRUdJTi...  # Base64 encoded RSA private key
  jwt-public-key: LS0tLS1CRUdJTi...   # Base64 encoded RSA public key
  jwt-access-secret: <base64-encoded-random-secret>
  jwt-refresh-secret: <base64-encoded-random-secret>
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: jwt-config
data:
  JWT_ALGORITHM: "RS256"
  JWT_ISSUER: "api.example.com"
  JWT_AUDIENCE: "app.example.com"
  JWT_ACCESS_TOKEN_EXPIRES: "15m"
  JWT_REFRESH_TOKEN_EXPIRES: "7d"
`;

// Generate RSA keys for JWT
"""
# Generate private key
openssl genpkey -algorithm RSA -out jwt-private.pem -pkeyopt rsa_keygen_bits:4096

# Generate public key
openssl rsa -pubout -in jwt-private.pem -out jwt-public.pem

# Generate random secrets
openssl rand -base64 64 > jwt-access-secret.txt
openssl rand -base64 64 > jwt-refresh-secret.txt
"""
```

## Detection Patterns

  * Weak JWT secrets: secret|password|12345|admin|jwt.
  * JWT token format: eyJ[A-Za-z0-9-_]+\.eyJ[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+.
  * Algorithm none: "alg"\s*:\s*"none".

## Prevention Best Practices

  1. Use strong, random secrets (minimum 256 bits).
  2. Prefer RS256 over HS256 for production.
  3. Keep token expiration times short.
  4. Implement token refresh rotation.
  5. Never store sensitive data in JWT payload.
  6. Validate all token claims.
  7. Implement token revocation/blacklisting.
  8. Use secure token storage (httpOnly cookies).
  9. Monitor for token anomalies.
  10. Regular key rotation.

