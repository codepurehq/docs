---
title: GitLab Tokens and CI Variables
description: Securing GitLab access tokens and CI/CD variables
---

## Common Misconfiguration

Exposed GitLab tokens can lead to unauthorized repository access, CI/CD pipeline manipulation, and container registry breaches.

### Vulnerable Example

```yaml
# VULNERABLE - .gitlab-ci.yml with hardcoded tokens
variables:
  # Never hardcode tokens!
  GITLAB_TOKEN: "glpat-xxxxxxxxxxxxxxxxxxxx"
  DEPLOY_TOKEN: "gldt-xxxxxxxxxxxxxxxxxxxx"
  REGISTRY_TOKEN: "glrt-xxxxxxxxxxxxxxxxxxxx"
  RUNNER_TOKEN: "GR1348941xxxxxxxxxxxxxxxxxxxx"

stages:
  - build
  - deploy

build:
  script:
    # Hardcoded project token
    - git clone https://gitlab-ci-token:glpat-xxxxxxxxxxxxxxxxxxxx@gitlab.com/org/private-repo.git
    - docker login -u gitlab-ci-token -p glpat-xxxxxxxxxxxxxxxxxxxx registry.gitlab.com
    
deploy:
  script:
    # Hardcoded deploy token
    - curl --header "PRIVATE-TOKEN: glpat-xxxxxxxxxxxxxxxxxxxx" "https://gitlab.com/api/v4/projects"
```

```javascript
// VULNERABLE - Hardcoded GitLab API credentials
const axios = require('axios');

class GitLabClient {
    constructor() {
        // Never hardcode these!
        this.personalAccessToken = 'glpat-xxxxxxxxxxxxxxxxxxxx';
        this.projectAccessToken = 'glpat-yyyy-xxxxxxxxxxxx';
        this.deployToken = {
            username: 'gitlab+deploy-token-1234',
            password: 'gldt-xxxxxxxxxxxxxxxxxxxx'
        };
        this.jobToken = process.env.CI_JOB_TOKEN || 'glctt-xxxxxxxxxxxxxxxxxxxx';
        this.feedToken = 'feed_token_xxxxxxxxxxxxxxxxxxxx';
        
        this.apiUrl = 'https://gitlab.com/api/v4';
    }
    
    async makeRequest(endpoint) {
        return axios.get(`${this.apiUrl}${endpoint}`, {
            headers: {
                'PRIVATE-TOKEN': this.personalAccessToken
            }
        });
    }
}
```

## Secure Example

```yaml
# SECURE - .gitlab-ci.yml using CI/CD variables
variables:
  DOCKER_REGISTRY: $CI_REGISTRY
  DOCKER_IMAGE: $CI_REGISTRY_IMAGE
  
stages:
  - build
  - test
  - deploy

before_script:
  # Use predefined CI variables
  - echo "Running in project ${CI_PROJECT_PATH}"
  - echo "Commit ${CI_COMMIT_SHA} on branch ${CI_COMMIT_REF_NAME}"

build:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  before_script:
    # Use CI_REGISTRY variables for authentication
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - docker build -t $DOCKER_IMAGE:$CI_COMMIT_SHA .
    - docker push $DOCKER_IMAGE:$CI_COMMIT_SHA
  only:
    - main
    - develop

deploy:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache curl git
  script:
    # Use masked CI/CD variables (set in project settings)
    - |
      curl --fail --request POST \
        --form token=$DEPLOY_TRIGGER_TOKEN \
        --form ref=main \
        --form "variables[ENVIRONMENT]=production" \
        "https://gitlab.com/api/v4/projects/${TARGET_PROJECT_ID}/trigger/pipeline"
  environment:
    name: production
    url: https://app.example.com
  only:
    - main
  when: manual

# Using GitLab's dependency proxy
dependency_proxy:
  stage: build
  image: ${CI_DEPENDENCY_PROXY_GROUP_IMAGE_PREFIX}/docker:latest
  script:
    - docker build -t myapp:latest .
```

```javascript
// SECURE - Using environment variables and secure token management
const axios = require('axios');

class SecureGitLabClient {
    constructor() {
        this.apiUrl = process.env.GITLAB_API_URL || 'https://gitlab.com/api/v4';
        this.token = null;
        this.tokenType = null;
    }
    
    async initialize() {
        // Check for different token types in order of preference
        if (process.env.CI_JOB_TOKEN) {
            // Use job token in CI/CD pipeline
            this.token = process.env.CI_JOB_TOKEN;
            this.tokenType = 'job-token';
        } else if (process.env.GITLAB_ACCESS_TOKEN) {
            // Use access token from environment
            this.token = process.env.GITLAB_ACCESS_TOKEN;
            this.tokenType = 'private-token';
        } else {
            throw new Error('No GitLab authentication token found');
        }
        
        // Validate token
        await this.validateToken();
    }
    
    async validateToken() {
        try {
            const response = await this.makeRequest('/user');
            console.log(`Authenticated as: ${response.data.username}`);
            return true;
        } catch (error) {
            throw new Error('GitLab token validation failed');
        }
    }
    
    async makeRequest(endpoint, options = {}) {
        const headers = {};
        
        // Set appropriate header based on token type
        if (this.tokenType === 'job-token') {
            headers['JOB-TOKEN'] = this.token;
        } else if (this.tokenType === 'private-token') {
            headers['PRIVATE-TOKEN'] = this.token;
        }
        
        return axios({
            url: `${this.apiUrl}${endpoint}`,
            headers,
            ...options
        });
    }
    
    async getProjectVariables(projectId) {
        // Get CI/CD variables (only returns non-sensitive data)
        const response = await this.makeRequest(
            `/projects/${projectId}/variables`
        );
        return response.data;
    }
    
    async createProtectedVariable(projectId, key, value) {
        // Create a protected and masked variable
        return this.makeRequest(
            `/projects/${projectId}/variables`,
            {
                method: 'POST',
                data: {
                    key: key,
                    value: value,
                    protected: true,  // Only available in protected branches
                    masked: true,     // Hidden in job logs
                    environment_scope: 'production'
                }
            }
        );
    }
}

// Docker example for secure GitLab registry access
const dockerConfig = `
FROM alpine:latest

# Use build arguments for sensitive data
ARG GITLAB_TOKEN
ARG REGISTRY_URL

# Don't store tokens in image layers
RUN --mount=type=secret,id=gitlab_token \
    apk add --no-cache curl && \
    curl -H "PRIVATE-TOKEN: $(cat /run/secrets/gitlab_token)" \
         https://gitlab.com/api/v4/projects > /dev/null && \
    rm -rf /var/cache/apk/*

# Multi-stage build to avoid token exposure
FROM alpine:latest
COPY --from=0 /app /app
`;

// Kubernetes GitLab integration
const k8sSecret = `
apiVersion: v1
kind: Secret
metadata:
  name: gitlab-registry
  namespace: default
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: <base64-encoded-docker-config>
---
apiVersion: v1
kind: Secret
metadata:
  name: gitlab-api-token
type: Opaque
stringData:
  token: ${GITLAB_TOKEN}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: gitlab-sync
spec:
  template:
    spec:
      containers:
      - name: sync
        image: alpine:latest
        env:
        - name: GITLAB_TOKEN
          valueFrom:
            secretKeyRef:
              name: gitlab-api-token
              key: token
      restartPolicy: Never
`;
```

## Detection Patterns

  * Personal Access Token: glpat-[a-zA-Z0-9\-\_].
  * Deploy Token: gldt-[a-zA-Z0-9\-\_].
  * Runner Registration Token: GR1348941[a-zA-Z0-9\-\_].
  * CI Job Token: glctt-[a-zA-Z0-9].
  * Feed Token: feed_token_[a-zA-Z0-9\-\_].

## Prevention Best Practices

  1. Use CI/CD variables instead of hardcoding.
  2. Enable variable masking and protection.
  3. Use job tokens with minimal scope.
  4. Implement token rotation policies.
  5. Use project/group access tokens instead of personal.
  6. Enable 2FA for all accounts.
  7. Audit token usage with GitLab audit events.
  8. Use GitLab's dependency proxy for external images.