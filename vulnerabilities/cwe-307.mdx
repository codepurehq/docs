---
title: "Improper Restriction of Excessive Authentication Attempts"
sidebarTitle: "Missing Brute-Force Protection (CWE-307)"
description: "Mitigation for missing rate limiting or lockouts on login attempts, allowing attackers to brute-force credentials."
icon: "keyboard"
iconType: "solid"
---

## Overview

This vulnerability occurs when an application **fails to limit the number of repeated authentication attempts** from a single user or IP address within a short period. Without such restrictions, attackers can use automated tools to rapidly submit thousands or millions of password guesses (**brute-force attack**) or common passwords (**dictionary attack**) against valid usernames. This significantly increases the likelihood of an attacker guessing a correct password and gaining unauthorized access. üîë‚û°Ô∏èüí•

---

## Business Impact

Failure to restrict excessive authentication attempts directly leads to:
* **Account Takeover:** Attackers can systematically guess weak or common passwords, compromising user accounts.
* **Denial of Service (Account Lockout):** If the *only* defense is permanent account lockout after a few tries, attackers can intentionally lock out legitimate users. A better approach often involves temporary lockouts or CAPTCHAs.
* **Resource Consumption:** Brute-force attacks can consume server CPU and network bandwidth.
* **Detection Evasion:** Slow, distributed brute-force attacks might go unnoticed if basic attempt logging is the only defense.

---

<Card title="Reference Details" icon="book-open" iconType:="solid">
  **CWE ID:** [CWE-307](https://cwe.mitre.org/data/definitions/307.html)
  **Related CWEs:** CWE-799 (Improper Control of Interaction Frequency), CWE-1216 (Lockout Errors)
  **OWASP Top 10 (2021):** A07:2021 - Identification and Authentication Failures
  **Severity:** High
</Card>

---

## Framework-Specific Analysis and Remediation

Brute-force protection is usually implemented via **rate limiting** (temporary blocking) or **account lockout** (temporary or requiring admin intervention). This often involves tracking failed login attempts per username and/or IP address in a cache (like Redis) or database. Many frameworks have plugins or built-in features, but custom logic is also common.

**Key Remediation Principles:**
1.  **Limit Attempts per IP:** Track failed login attempts by IP address and temporarily block IPs with excessive failures (e.g., block for 5 minutes after 20 attempts).
2.  **Limit Attempts per Username:** Track failed login attempts *per username* and implement stronger protections like temporary account lockout (e.g., lock for 30 minutes after 5 failed attempts) or requiring a CAPTCHA.
3.  **Use Exponential Backoff:** Increase the lockout duration after repeated lockout events for the same account or IP.
4.  **Secure Lockout Mechanism:** Ensure the lockout mechanism itself cannot be abused for Denial of Service (e.g., avoid permanent lockouts triggered solely by failed attempts).
5.  **Logging and Monitoring:** Log failed login attempts and lockout events to detect attacks. Alert administrators to high rates of failures.

---

<Tabs>
  <Tab title="Python">
    #### Framework Context
    Using libraries like `django-ratelimit`, `django-axes`, `Flask-Limiter` to apply limits specifically to login views.

    #### Vulnerable Scenario 1: Django Login View without Limits
    ```python
    # accounts/views.py
    from django.contrib.auth.views import LoginView

    class UserLoginView(LoginView):
        template_name = 'accounts/login.html'
        # DANGEROUS: No rate limiting or lockout mechanism applied.
        # Vulnerable to brute-force attacks against user passwords.
    ```

    #### Vulnerable Scenario 2: Flask Login Route without Limits
    ```python
    # app.py (Flask)
    @app.route('/login', methods=['GET', 'POST'])
    def login():
        if request.method == 'POST':
            username = request.form['username']
            password = request.form['password']
            user = find_user(username)
            # DANGEROUS: No tracking of failed attempts per username or IP.
            if user and check_password_hash(user.password_hash, password):
                login_user(user) # Assume Flask-Login
                return redirect('/dashboard')
            else:
                flash('Invalid credentials') # Failure not tracked/limited
        return render_template('login.html')
    ```

    #### Mitigation and Best Practices
    * **Django:** Use `django-axes` to track failed login attempts and implement lockouts, or use `django-ratelimit` to throttle login attempts based on IP, username, or other keys.
    * **Flask:** Use `Flask-Limiter` to apply rate limits to the login route based on IP address and potentially form fields (`username`).

    #### Secure Code Example
    ```python
    # views.py (Django with django-axes - Configuration in settings.py)
    # settings.py:
    # INSTALLED_APPS = [..., 'axes', ...]
    # AUTHENTICATION_BACKENDS = ['axes.backends.AxesStandaloneBackend', ...] # Or AxesModelBackend
    # AXES_FAILURE_LIMIT = 5 # Lockout after 5 attempts
    # AXES_COOLOFF_TIME = timedelta(minutes=15) # Lockout duration
    # AXES_LOCKOUT_TEMPLATE = 'accounts/lockout.html' # Custom lockout page
    # AXES_HANDLER = 'axes.handlers.database.AxesDatabaseHandler' # Store attempts in DB
    # --- views.py needs no specific axes code if using backend ---
    # LoginView will automatically use the Axes backend if configured.

    # views.py (Django with django-ratelimit)
    from ratelimit.decorators import ratelimit
    from django.utils.decorators import method_decorator

    class UserLoginViewSecureRL(LoginView):
        template_name = 'accounts/login.html'
        # SECURE: Rate limit based on username in POST data + IP
        @method_decorator(ratelimit(key='post:username', rate='5/m', block=True, method='POST'), name='dispatch')
        def dispatch(self, *args, **kwargs):
            return super().dispatch(*args, **kwargs)
    ```
    ```python
    # app.py (Flask with Flask-Limiter)
    from flask_limiter import Limiter
    from flask_limiter.util import get_remote_address

    limiter = Limiter(get_remote_address, app=app, storage_uri="memory://") # Use Redis in prod

    @app.route('/login-secure', methods=['GET', 'POST'])
    # SECURE: Limit POST requests based on IP AND username form field
    @limiter.limit("5 per minute", key_func=lambda: f"{get_remote_address()}:{request.form.get('username')}", methods=['POST'])
    def login_secure():
        if request.method == 'POST':
            # ... login logic ...
            if login_successful:
                 limiter.reset() # Optional: Reset limit on success for this key
                 # ...
            else:
                 # Limit applied automatically by decorator
                 flash('Invalid credentials')
        return render_template('login.html')
    ```

    #### Testing Strategy
    Use an automated tool (Burp Intruder, Hydra, custom script) to submit multiple invalid password attempts for a valid username to the login endpoint. Verify that after the configured number of attempts (e.g., 5), subsequent requests are blocked (e.g., `429 Too Many Requests`, `403 Forbidden`, lockout page) for the configured duration. Test throttling by IP address as well by attacking different usernames from the same IP.
  </Tab>
  <Tab title="Java">
    #### Framework Context
    Implementing custom listeners or providers in Spring Security to track failed attempts, or using libraries like Bucket4j for rate limiting on the login endpoint.

    #### Vulnerable Scenario 1: Default Spring Security Form Login
    The basic `formLogin()` configuration doesn't include brute-force protection out of the box.
    ```java
    // config/SecurityConfig.java
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests().anyRequest().authenticated().and()
            // DANGEROUS: No protection against repeated failed login attempts.
            .formLogin().permitAll();
    }
    ```

    #### Vulnerable Scenario 2: Custom Authentication Logic without Tracking
    A custom authentication method doesn't track or limit failures.
    ```java
    // service/AuthService.java
    public boolean authenticate(String username, String password) {
        UserDetails user = userDetailsService.loadUserByUsername(username);
        // DANGEROUS: Failure count is not tracked or limited.
        if (user != null && passwordEncoder.matches(password, user.getPassword())) {
             // Success logic
             return true;
        } else {
             // Failure logic - no tracking/blocking
             return false;
        }
    }
    ```

    #### Mitigation and Best Practices
    * **Spring Security:** Implement an `AuthenticationFailureHandler` and/or `AuthenticationSuccessHandler` to track failed/successful attempts per username/IP (e.g., storing counts in a cache like Redis or Guava). Before attempting authentication, check the failure count and throw a `LockedException` or similar if the threshold is exceeded.
    * **Rate Limiting:** Apply a rate-limiting filter (like the Bucket4j example in `CWE-799`) specifically to the login processing URL, keyed by IP address and potentially the username parameter.

    #### Secure Code Example
    ```java
    // config/LoginAttemptService.java (Example using Guava Cache)
    import com.google.common.cache.CacheBuilder;
    import com.google.common.cache.CacheLoader;
    import com.google.common.cache.LoadingCache;
    import org.springframework.stereotype.Service;
    import java.util.concurrent.ExecutionException;
    import java.util.concurrent.TimeUnit;

    @Service
    public class LoginAttemptService {
        private final int MAX_ATTEMPTS = 5;
        private LoadingCache<String, Integer> attemptsCache; // Key = IP Address or Username

        public LoginAttemptService() {
            attemptsCache = CacheBuilder.newBuilder()
                .expireAfterWrite(15, TimeUnit.MINUTES) // Cache expiry / lockout duration
                .build(new CacheLoader<String, Integer>() {
                    public Integer load(String key) { return 0; } // Default attempts = 0
                });
        }

        public void loginFailed(String key) {
            int attempts = 0;
            try {
                attempts = attemptsCache.get(key);
            } catch (ExecutionException e) { /* Handle cache error */ }
            attempts++;
            attemptsCache.put(key, attempts);
        }

        public void loginSucceeded(String key) {
            attemptsCache.invalidate(key);
        }

        public boolean isBlocked(String key) {
            try {
                return attemptsCache.get(key) >= MAX_ATTEMPTS;
            } catch (ExecutionException e) { return false; /* Fail open on cache error? Or block? */ }
        }
    }

    // config/AuthenticationFailureListener.java (Example Listener)
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.ApplicationListener;
    import org.springframework.security.authentication.event.AuthenticationFailureBadCredentialsEvent;
    import org.springframework.stereotype.Component;
    import javax.servlet.http.HttpServletRequest; // Need request for IP

    @Component
    public class AuthenticationFailureListener
           implements ApplicationListener<AuthenticationFailureBadCredentialsEvent> {

        @Autowired private HttpServletRequest request; // Inject request for IP
        @Autowired private LoginAttemptService loginAttemptService;

        @Override
        public void onApplicationEvent(AuthenticationFailureBadCredentialsEvent e) {
            final String xfHeader = request.getHeader("X-Forwarded-For");
            String key; // Track by IP
            if (xfHeader == null) {
                key = request.getRemoteAddr();
            } else {
                key = xfHeader.split(",")[0]; // Get client IP from proxy header
            }
            // Could also extract username: e.getAuthentication().getName();
            loginAttemptService.loginFailed(key);
        }
    }
    // Need a similar AuthenticationSuccess Listener to call loginSucceeded.
    // Need to check isBlocked() *before* attempting auth (e.g., in a custom filter or provider).
    ```

    #### Testing Strategy
    Use automated tools to send repeated invalid login attempts. Monitor failure counts (if exposed via logs or an endpoint). Verify that after the threshold, login attempts from that IP/username are blocked with an appropriate error message or status code (e.g., 401/403 with lockout message, or 429 if using rate limiting) for the specified duration.
  </Tab>
  <Tab title=".NET(C#)">
    #### Framework Context
    ASP.NET Core Identity includes **account lockout** features configurable in `Startup.cs`. Rate limiting can be added via `AspNetCoreRateLimit`.

    #### Vulnerable Scenario 1: Account Lockout Disabled
    The default Identity configuration might have lockout disabled or set with very high thresholds.
    ```csharp
    // Startup.cs (ConfigureServices)
    services.AddDefaultIdentity<IdentityUser>(options => {
        // ... other options ...
        // DANGEROUS: Lockout might be disabled by default or configured weakly.
        options.Lockout.AllowedForNewUsers = false; // Example: Disabled
        options.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(1); // Too short?
        options.Lockout.MaxFailedAccessAttempts = 100; // Too high!
    })
    .AddEntityFrameworkStores<ApplicationDbContext>();
    ```

    #### Vulnerable Scenario 2: No General Rate Limiting
    Even with account lockout, attackers can still try many usernames from one IP or target APIs without lockout. Missing general rate limiting (like `AspNetCoreRateLimit`) allows this. (See CWE-799 example).

    #### Mitigation and Best Practices
    * **Enable Identity Lockout:** Configure `IdentityOptions.Lockout` with sensible values (e.g., `MaxFailedAccessAttempts = 5`, `DefaultLockoutTimeSpan = TimeSpan.FromMinutes(15)`). Ensure `AllowedForNewUsers = true`.
    * **Implement Rate Limiting:** Use `AspNetCoreRateLimit` (see `CWE-799`) to throttle requests to the login endpoint based on IP address as a first line of defense before Identity's user-specific lockout engages.

    #### Secure Code Example
    ```csharp
    // Startup.cs (ConfigureServices - Secure Identity Lockout)
    services.AddDefaultIdentity<IdentityUser>(options => {
        options.SignIn.RequireConfirmedAccount = true; // Good practice
        // SECURE: Configure sensible lockout settings.
        options.Lockout.AllowedForNewUsers = true;
        options.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(15); // 15-minute lockout
        options.Lockout.MaxFailedAccessAttempts = 5; // Lock after 5 failed attempts
    })
    .AddEntityFrameworkStores<ApplicationDbContext>();

    // Add AspNetCoreRateLimit configuration as shown in CWE-799 example,
    // ensuring the login endpoint has appropriate IP-based rules, e.g.:
    // { "Endpoint": "*:/Account/Login", "Period": "1m", "Limit": 10 } // Limit per IP before user lockout
    ```
    ```csharp
    // Controllers/AccountController.cs (Ensure lockoutOnFailure is true)
    public async Task<IActionResult> Login(LoginViewModel model)
    {
        // ... find user ...
        // SECURE: Ensure lockoutOnFailure is true (default is often false).
        var result = await _signInManager.PasswordSignInAsync(user, model.Password, model.RememberMe,
            lockoutOnFailure: true);

        if (result.Succeeded) { /* ... */ }
        if (result.IsLockedOut) {
             _logger.LogWarning("User account locked out.");
             return RedirectToAction("Lockout"); // Show lockout page
        }
        // ... handle other failures ...
    }
    ```

    #### Testing Strategy
    Submit multiple (e.g., 6) incorrect passwords for a valid user. Verify the account becomes locked (user cannot log in even with correct password) and the `LockoutEnd` date is set in the `AspNetUsers` table. Check the lockout duration. Use tools to send rapid requests from one IP to the login endpoint and verify rate limiting (429 responses) occurs before account lockout if both are configured.
  </Tab>
  <Tab title="PHP">
    #### Framework Context
    Laravel provides login throttling out of the box (`Illuminate\Foundation\Auth\ThrottlesLogins` trait in `LoginController`). Plain PHP requires manual implementation.

    #### Vulnerable Scenario 1: Login Throttling Disabled (Laravel)
    A developer removes or overrides the `ThrottlesLogins` trait or related methods in `app/Http/Controllers/Auth/LoginController.php`.
    ```php
    // app/Http/Controllers/Auth/LoginController.php (Modified)
    namespace App\Http\Controllers\Auth;
    // ... use statements ...
    class LoginController extends Controller
    {
        // DANGEROUS: The ThrottlesLogins trait is removed or commented out.
        // use ThrottlesLogins;

        // ... constructor, redirectTo etc. ...

        // If the trait is missing, the default login action won't throttle.
    }
    ```

    #### Vulnerable Scenario 2: Plain PHP without Attempt Tracking
    ```php
    <?php
    // login.php (Plain PHP)
    session_start();
    // ... get username, password from POST ...
    $stored_hash = get_password_hash_from_db($username);

    // DANGEROUS: No tracking of failed attempts.
    if ($stored_hash && password_verify($input_password, $stored_hash)) {
        session_regenerate_id(true);
        $_SESSION['user_id'] = get_user_id($username);
        header('Location: /dashboard.php');
        exit;
    } else {
        // Failure, but no limit implemented
        header('Location: /login.php?error=1');
        exit;
    }
    ?>
    ```

    #### Mitigation and Best Practices
    * **Laravel:** Ensure the `ThrottlesLogins` trait is used in your `LoginController`. Configure the number of attempts (`maxAttempts`) and decay minutes (`decayMinutes`) via methods in the controller if you need to override defaults (defaults are usually reasonable: 5 attempts, 1 minute decay).
    * **Plain PHP:** Implement failed attempt tracking. Store failure counts and timestamps per username and/or IP address (e.g., in session, database, or cache like Redis/Memcached). Before checking the password, check the attempt count/timestamp; if exceeded, display an error and deny the attempt until the lockout period expires.

    #### Secure Code Example
    ```php
    // app/Http/Controllers/Auth/LoginController.php (Laravel - Secure Default)
    namespace App\Http\Controllers\Auth;
    use App\Http\Controllers\Controller;
    use Illuminate\Foundation\Auth\AuthenticatesUsers;
    // SECURE: Include the ThrottlesLogins trait.
    use Illuminate\Foundation\Auth\ThrottlesLogins;

    class LoginController extends Controller
    {
        // Use AuthenticatesUsers for standard login logic
        use AuthenticatesUsers, ThrottlesLogins; // Ensure ThrottlesLogins is present

        // Optional: Override defaults if needed
        // protected $maxAttempts = 3; // Default is 5
        // protected $decayMinutes = 2; // Default is 1

        protected $redirectTo = '/home';

        public function __construct() { /* ... */ }

        // Override username() if not using 'email'
        // public function username() { return 'username'; }
    }
    ```
    ```php
    <?php
    // login_secure.php (Plain PHP - Conceptual Example)
    session_start();
    define('MAX_LOGIN_ATTEMPTS', 5);
    define('LOCKOUT_TIME_SECONDS', 15 * 60); // 15 minutes

    $username = $_POST['username'] ?? '';
    $password = $_POST['password'] ?? '';
    $ip_address = $_SERVER['REMOTE_ADDR'];

    // Use a persistent store (DB, Redis, Memcached) for attempts, not session alone
    // Example keys: "login_attempt_ip:$ip_address", "login_attempt_user:$username"
    $ip_attempts = get_failed_attempts("ip:$ip_address"); // Assume function exists
    $user_attempts = get_failed_attempts("user:$username"); // Assume function exists

    // Check lockout
    if ($ip_attempts >= MAX_LOGIN_ATTEMPTS * 2 || $user_attempts >= MAX_LOGIN_ATTEMPTS) {
        // Check if lockout time has passed (needs timestamp storage)
        if (!is_lockout_expired("user:$username")) { // Assume function exists
             die("Too many failed attempts. Please try again later.");
        } else {
             reset_failed_attempts("user:$username"); // Reset if expired
             // Optionally reset IP too, or handle IPs differently
        }
    }

    $stored_hash = get_password_hash_from_db($username);

    if ($stored_hash && password_verify($password, $stored_hash)) {
        reset_failed_attempts("ip:$ip_address");
        reset_failed_attempts("user:$username");
        session_regenerate_id(true);
        $_SESSION['user_id'] = get_user_id($username);
        header('Location: /dashboard.php');
        exit;
    } else {
        // Record failed attempt
        record_failed_attempt("ip:$ip_address");
        if ($username) { record_failed_attempt("user:$username"); }
        header('Location: /login.php?error=1');
        exit;
    }
    // Need helper functions: get_failed_attempts, is_lockout_expired, reset_failed_attempts, record_failed_attempt
    ?>
    ```

    #### Testing Strategy
    Use automated tools (Burp Intruder, Hydra) to send multiple invalid password attempts for a valid username. Verify that after the threshold (e.g., 5 in Laravel default), subsequent attempts are blocked with a specific error message and a `429 Too Many Requests` status code. Check the lockout duration. Test attacks against different users from the same IP and the same user from different IPs.
  </Tab>
  <Tab title="Node.js">
    #### Framework Context
    Using rate-limiting middleware (`express-rate-limit`, `rate-limiter-flexible`) specifically configured for the login route, potentially keyed by IP and username.

    #### Vulnerable Scenario 1: Login Route without Rate Limiting
    ```javascript
    // app.js
    app.post('/login', async (req, res) => {
        const { username, password } = req.body;
        // DANGEROUS: No limit on how often this can be called.
        const user = await User.findOne({ username });
        if (user && await bcrypt.compare(password, user.passwordHash)) {
            // ... login success ...
        } else {
            // Failure, but no tracking/limiting
            res.status(401).send('Invalid credentials');
        }
    });
    ```

    #### Vulnerable Scenario 2: Rate Limiter Only By IP
    While better than nothing, only limiting by IP allows an attacker to brute-force *many different usernames* from the same IP address without hitting the limit for any single user.
    ```javascript
    // app.js
    const loginLimiter = rateLimit({
        windowMs: 15 * 60 * 1000, // 15 minutes
        max: 100, // Limit each IP to 100 requests per windowMs
        // DANGEROUS: Doesn't consider username. Attacker tries 100 different users.
    });
    app.post('/login-ip-limited', loginLimiter, async (req, res) => { /* ... */ });
    ```

    #### Mitigation and Best Practices
    Apply rate-limiting middleware (like `express-rate-limit`) to the login route. Configure it with a strict limit (`max`) and reasonable window (`windowMs`). Crucially, use a `keyGenerator` function that includes **both the IP address and the username** from the request body to prevent attackers from cycling through usernames.

    #### Secure Code Example
    ```javascript
    // app.js (Secure Login Limiter)
    const rateLimit = require('express-rate-limit');
    const app = require('express')(); // Initialize app
    app.use(express.json()); // Middleware to parse JSON body
    app.use(express.urlencoded({ extended: true })); // Middleware to parse form body

    const loginLimiter = rateLimit({
        windowMs: 15 * 60 * 1000, // 15 minutes
        max: 5, // SECURE: Limit each user/IP combination to 5 attempts per window
        message: 'Too many login attempts, please try again after 15 minutes',
        standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
        legacyHeaders: false, // Disable the `X-RateLimit-*` headers
        // SECURE: Key includes both IP and username from form body
        keyGenerator: (req, res) => {
             // Ensure username exists and is sanitized if necessary, handle potential errors
             const username = req.body.username || 'unknown_user';
             // Use req.ip (requires `app.set('trust proxy', 1)` if behind proxy)
             return req.ip + ':' + username.toLowerCase();
        },
        // Optional: Handler to log blocked requests
        // handler: (req, res, next, options) => {
        //    log.warn(`Rate limit exceeded for key: ${options.keyGenerator(req, res)}`);
        //    res.status(options.statusCode).send(options.message);
        // }
    });

    // Apply the limiter ONLY to the login POST route
    app.post('/login-secure', loginLimiter, async (req, res) => {
        const { username, password } = req.body;
        // ... authentication logic (find user, bcrypt.compare) ...
        if (login_successful) {
            // Optional: Reset limiter count on success? Depends on library/store.
            // Some stores might have methods like limiter.resetKey(key)
             // ... login success (regenerate session etc.) ...
        } else {
             // Rate limiter handles blocking if needed before this point
             res.status(401).send('Invalid credentials');
        }
    });
    // ... other routes ...
    ```

    #### Testing Strategy
    Use automated tools to send rapid, invalid password attempts for a *single valid username*. Verify that requests are blocked (429 response) after the `max` limit. Wait for `windowMs` and verify login is possible again. Repeat the test, but cycle through *different valid usernames* from the *same IP address*. Verify the IP-based limit (if separate) or the combined key limit functions correctly.
  </Tab>
  <Tab title="Ruby">
    #### Framework Context
    Using `rack-attack` gem with specific throttle rules for login paths, keyed by IP and relevant parameters (like email).

    #### Vulnerable Scenario 1: Devise Login Without `rack-attack`
    A standard Devise setup without `rack-attack` configured.
    ```ruby
    # config/routes.rb
    devise_for :users # Standard Devise routes
    # DANGEROUS: No rack-attack initializer or middleware configured.
    # The /users/sign_in endpoint is vulnerable to brute-force.
    ```

    #### Vulnerable Scenario 2: `rack-attack` Configured but Missing Login Path
    ```ruby
    # config/initializers/rack_attack.rb
    Rack::Attack.throttle('req/ip', limit: 100, period: 5.minutes, &:ip)
    # DANGEROUS: General request limit exists, but no specific,
    # stricter limit for the sensitive POST /users/sign_in path.
    # 100 attempts in 5 mins might be too high for login.
    ```

    #### Mitigation and Best Practices
    Configure `rack-attack` middleware. Define specific, stricter `throttle` rules for the login path (`POST /users/sign_in` for Devise). Key the throttle by both IP address (`req.ip`) and the submitted email/username parameter (`req.params['user']['email']`) to prevent username cycling from a single IP.

    #### Secure Code Example
    ```ruby
    # config/initializers/rack_attack.rb (Secure)
    class Rack::Attack

      # Throttle all requests by IP (general protection)
      # Adjust limit & period based on application needs
      throttle('req/ip', limit: 60, period: 1.minute, &:ip)

      # Throttle POST requests to /users/sign_in by IP address
      # Limit: 5 requests per minute per IP
      throttle('logins/ip', limit: 5, period: 60.seconds) do |req|
        if req.path == '/users/sign_in' && req.post?
          req.ip
        end
      end

      # Throttle POST requests to /users/sign_in by email param
      # Limit: 5 requests per 15 minutes per email address (adjust period)
      # This prevents hammering a single user account from multiple IPs.
      throttle('logins/email', limit: 5, period: 15.minutes) do |req|
         if req.path == '/users/sign_in' && req.post?
           # Ensure email param exists, handle nil, normalize (downcase, strip)
           req.params['user']['email'].to_s.downcase.strip.presence
         end
      end

      # Customize response (optional but recommended)
       self.throttled_response = lambda do |env|
         now = Time.now
         match_data = env['rack.attack.match_data']
         retry_after = match_data[:period] - (now.to_i % match_data[:period])

         headers = {
           'Content-Type' => 'application/json',
           'Retry-After' => retry_after.to_s
         }
         [ 429, headers, [{ error: "Throttle limit exceeded. Retry later." }.to_json] ]
       end

       # Track failures for potential blocking (Fail2Ban style) - Optional
       # Rack::Attack.track("logins/ip/failures", limit: 10, period: 5.minutes) do |req|
       #    req.ip if req.path == '/users/sign_in' && req.post? # Track attempts
       # end
       # Use Rack::Attack.blocklist based on track count if needed.
    end

    # config/application.rb (Ensure middleware is used)
    # module MyApp
    #  class Application < Rails::Application
    #     config.middleware.use Rack::Attack
    #  end
    # end
    ```

    #### Testing Strategy
    Use automated tools to send multiple invalid password attempts to the login path (`/users/sign_in`). Verify that `429 Too Many Requests` responses are received after exceeding the configured limits (e.g., 5 attempts per minute per IP, 5 attempts per 15 minutes per email). Check the `Retry-After` header. Test hammering different email addresses from the same IP, and the same email address from different IPs.
  </Tab>
</Tabs>