---
title: "Useeeeeeee of a Broken or Risky Cryptographic Algorithm"
sidebarTitle: "Broken/Risky Crypto (CWE-327)"
description: "Mitigation for using weak or broken crypto (MD5, SHA1, DES) in Django, Spring Boot, Rails, Express, ASP.NET Core, and Laravel."
icon: "unlock-keyhole"
iconType: "solid"
---

## Overview
This vulnerability occurs when an application uses cryptographic algorithms that are known to be weak, broken, or deprecated. This includes using outdated hashing algorithms like MD5 or SHA1 for password storage, using weak encryption ciphers like DES, or employing cryptographic modes that are susceptible to attacks (like ECB mode for block ciphers).

## Business Impact
Using broken cryptography provides a false sense of security. üõ°Ô∏è Attackers can often break this weak protection easily, leading to the compromise of sensitive data like passwords, PII, or financial information. If password hashes are cracked, attackers gain access to user accounts. If encryption is broken, all encrypted data is exposed.

<Card title="Reference Details" icon="book-open" iconType:="solid">
  **CWE ID:** [CWE-327](https://cwe.mitre.org/data/definitions/327.html)
  **OWASP Top 10 (2021):** A02:2021 - Cryptographic Failures
  **Severity:** High
</Card>

## Framework-Specific Analysis and Remediation
Modern frameworks generally default to strong algorithms (e.g., bcrypt/Argon2 for passwords, AES-GCM for encryption). This vulnerability arises when developers:
1.  Explicitly choose a weak algorithm (often for legacy compatibility or misunderstanding).
2.  Use outdated libraries or configurations.
3.  Implement crypto manually instead of using framework defaults.

The fix is to **always use current, industry-standard algorithms** recommended by NIST or other reputable bodies and rely on the framework's built-in secure defaults.

<Tabs>
  <Tab title="Python">
    #### Framework Context
    Django defaults to PBKDF2_SHA256 for passwords, which is acceptable but bcrypt or Argon2 are stronger. For encryption, developers might use the older `hashlib` for passwords or weak `pycryptodome` configurations.

    #### Vulnerable Scenario 1: Using MD5 for Passwords
    A legacy system or custom user model uses MD5 directly.
    ```python
    # models.py (Custom User Model)
    import hashlib

    def check_password(self, raw_password):
        # DANGEROUS: MD5 is broken and easily cracked.
        return hashlib.md5(raw_password.encode()).hexdigest() == self.password_hash
    ```

    #### Vulnerable Scenario 2: Weak Encryption Cipher
    Using `pycryptodome` with DES or ECB mode.
    ```python
    # utils/encryption.py
    from Crypto.Cipher import DES, AES
    from Crypto.Random import get_random_bytes

    def encrypt_data_des(key, data):
        # DANGEROUS: DES has a small key size (56-bit) and is broken.
        cipher = DES.new(key, DES.MODE_ECB) # ECB mode is also insecure
        return cipher.encrypt(pad(data))
        
    def encrypt_data_aes_ecb(key, data):
        # DANGEROUS: AES itself is strong, but ECB mode leaks patterns.
        cipher = AES.new(key, AES.MODE_ECB)
        return cipher.encrypt(pad(data))
    ```

    #### Mitigation and Best Practices
    Use Django's default password hashing (`django.contrib.auth.hashers`). If you need stronger hashing, configure `PASSWORD_HASHERS` to prioritize `bcrypt` or `Argon2`. For encryption, use `AES` with `GCM` mode (provides integrity) or `CBC` mode with a random IV and MAC.

    #### Secure Code Example
    ```python
    # settings.py (Secure Password Hashers)
    PASSWORD_HASHERS = [
        'django.contrib.auth.hashers.Argon2PasswordHasher', # Preferred
        'django.contrib.auth.hashers.BCryptSHA256PasswordHasher',
        'django.contrib.auth.hashers.PBKDF2PasswordHasher',
        'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher', # Legacy support only
    ]

    # utils/encryption.py (Secure AES-GCM)
    from Crypto.Cipher import AES
    from Crypto.Random import get_random_bytes

    def encrypt_data_aes_gcm(key, data):
        # SECURE: AES-GCM provides confidentiality and integrity.
        nonce = get_random_bytes(12)
        cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)
        ciphertext, tag = cipher.encrypt_and_digest(data.encode())
        # Store or transmit nonce + ciphertext + tag
        return nonce + ciphertext + tag 
    ```

    #### Testing Strategy
    Check the `password` field in your user database. Hashes should start with prefixes like `argon2$`, `bcrypt$`, or `pbkdf2_sha256$`, not just raw hex. For encryption, write unit tests ensuring the correct algorithm (AES) and mode (GCM/CBC) are used.
  </Tab>
  <Tab title="Java">
    #### Framework Context
    Spring Security defaults to `BCryptPasswordEncoder`, which is secure. Vulnerabilities arise from using older `PasswordEncoder` implementations or Java's `Cipher` class with weak algorithms.

    #### Vulnerable Scenario 1: Using MD5/SHA1 PasswordEncoder
    Configuring Spring Security to use an old, insecure `PasswordEncoder`.
    ```java
    // config/SecurityConfig.java
    @Bean
    public PasswordEncoder passwordEncoder() {
        // DANGEROUS: MD5 is broken.
        // Also avoid SHA1PasswordEncoder, PlaintextPasswordEncoder.
        return new MessageDigestPasswordEncoder("MD5"); 
    }
    ```

    #### Vulnerable Scenario 2: Using Weak Cipher Algorithm/Mode
    Using `javax.crypto.Cipher` with DES or ECB mode.
    ```java
    // service/EncryptionService.java
    import javax.crypto.Cipher;
    import javax.crypto.spec.SecretKeySpec;

    public byte[] encryptDesEcb(byte[] keyBytes, byte[] data) throws Exception {
        // DANGEROUS: DES/ECB is insecure.
        SecretKeySpec key = new SecretKeySpec(keyBytes, "DES");
        Cipher cipher = Cipher.getInstance("DES/ECB/PKCS5Padding"); 
        cipher.init(Cipher.ENCRYPT_MODE, key);
        return cipher.doFinal(data);
    }
    ```

    #### Mitigation and Best Practices
    Use `BCryptPasswordEncoder` (default) or `Argon2PasswordEncoder`. For encryption, use `AES/GCM/NoPadding`. Ensure a random IV/nonce is generated for each encryption.

    #### Secure Code Example
    ```java
    // config/SecurityConfig.java (Secure)
    @Bean
    public PasswordEncoder passwordEncoder() {
        // SECURE: BCrypt is the default and recommended.
        // Or use Argon2PasswordEncoder.
        return new BCryptPasswordEncoder(); 
    }

    // service/EncryptionService.java (Secure AES-GCM)
    import javax.crypto.Cipher;
    import javax.crypto.spec.GCMParameterSpec;
    import javax.crypto.spec.SecretKeySpec;
    import java.security.SecureRandom;

    public byte[] encryptAesGcm(byte[] keyBytes, byte[] data) throws Exception {
        // SECURE: AES/GCM/NoPadding is recommended.
        SecretKeySpec key = new SecretKeySpec(keyBytes, "AES");
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        
        // Use a random 12-byte nonce
        byte[] nonce = new byte[12];
        new SecureRandom().nextBytes(nonce);
        GCMParameterSpec spec = new GCMParameterSpec(128, nonce); // 128-bit tag

        cipher.init(Cipher.ENCRYPT_MODE, key, spec);
        
        byte[] ciphertext = cipher.doFinal(data);
        // Prepend nonce to ciphertext for storage/transmission
        byte[] result = new byte[nonce.length + ciphertext.length];
        System.arraycopy(nonce, 0, result, 0, nonce.length);
        System.arraycopy(ciphertext, 0, result, nonce.length, ciphertext.length);
        return result;
    }
    ```

    #### Testing Strategy
    Check password hashes in the database; they should start with `$2a$` or `$argon2id$`. Write unit tests for encryption code, asserting that `AES/GCM/NoPadding` is the algorithm specified.
  </Tab>
  <Tab title=".NET(C#)">
    #### Framework Context
    ASP.NET Core Identity defaults to `PBKDF2` with HMAC-SHA256, which is acceptable. Vulnerabilities can arise from using older membership providers or configuring weaker hashers. Manual encryption might use weak `SymmetricAlgorithm` subclasses.

    #### Vulnerable Scenario 1: Legacy Membership Provider Hasher
    Configuring ASP.NET Identity to use an older, weaker hashing algorithm for compatibility.
    ```csharp
    // Startup.cs (ConfigureServices)
    services.AddIdentity<ApplicationUser, IdentityRole>(options => {
        // DANGEROUS: V2 uses SHA1, V3 uses PBKDF2. Avoid V2.
        options.Password.RequireDigit = false; // Example option
        options.PasswordHasherCompatibilityMode = PasswordHasherCompatibilityMode.IdentityV2;
    })
    ```

    #### Vulnerable Scenario 2: Using Weak Algorithm (DES/TripleDES)
    Manually encrypting data using `DESCryptoServiceProvider`.
    ```csharp
    // Services/EncryptionService.cs
    using System.Security.Cryptography;

    public byte[] EncryptDes(byte[] key, byte[] data)
    {
        // DANGEROUS: DES is broken. Avoid TripleDES too.
        using (var des = DES.Create()) 
        {
            des.Key = key;
            des.Mode = CipherMode.ECB; // DANGEROUS: ECB is weak
            using (var encryptor = des.CreateEncryptor())
            // ... encryption logic ...
        }
    }
    ```

    #### Mitigation and Best Practices
    Use the default ASP.NET Core Identity password hasher (PBKDF2 HMAC-SHA256 or newer). For custom encryption, use `AesGcm` (preferred, .NET Core 3.0+) or `AesCng` / `AesCryptoServiceProvider` with CBC mode and an HMAC for integrity.

    #### Secure Code Example
    ```csharp
    // Startup.cs (ConfigureServices - Secure Default)
    services.AddDefaultIdentity<ApplicationUser>(options => {
        // Default hasher is secure (PBKDF2 HMAC-SHA256)
        options.SignIn.RequireConfirmedAccount = true;
    })
    .AddEntityFrameworkStores<ApplicationDbContext>();

    // Services/EncryptionService.cs (Secure AES-GCM)
    using System.Security.Cryptography;

    public byte[] EncryptAesGcm(byte[] key, byte[] data)
    {
        // SECURE: AES-GCM provides confidentiality and integrity.
        using (var aes = new AesGcm(key))
        {
            var nonce = new byte[AesGcm.NonceByteSizes.MaxSize]; // 12 bytes
            RandomNumberGenerator.Fill(nonce);
            var tag = new byte[AesGcm.TagByteSizes.MaxSize]; // 16 bytes
            var ciphertext = new byte[data.Length];

            aes.Encrypt(nonce, data, ciphertext, tag);
            
            // Return nonce + tag + ciphertext for storage/transmission
            byte[] result = new byte[nonce.Length + tag.Length + ciphertext.Length];
            // ... combine arrays ...
            return result;
        }
    }
    ```

    #### Testing Strategy
    Check password hashes in the `AspNetUsers` table. They should be long, non-obvious strings (Base64 encoded PBKDF2). Write unit tests for encryption code, asserting the use of `AesGcm` or `Aes`.
  </Tab>
  <Tab title="PHP">
    #### Framework Context
    Laravel defaults to `bcrypt` for password hashing (`Hash::make`), which is secure. Vulnerabilities occur if developers manually use `md5()` or `sha1()`. For encryption, Laravel uses AES-256-CBC by default (`Crypt::encrypt`), which needs careful handling regarding integrity.

    #### Vulnerable Scenario 1: Using `md5()` for Passwords
    A developer manually hashes a password using `md5()`.
    ```php
    // app/Http/Controllers/RegisterController.php
    protected function create(array $data)
    {
        return User::create([
            'name' => $data['name'],
            'email' => $data['email'],
            // DANGEROUS: md5() is broken.
            'password' => md5($data['password']), 
        ]);
    }
    ```

    #### Vulnerable Scenario 2: Using `openssl_encrypt` with Weak Parameters
    Manually encrypting data using `openssl_encrypt` with DES or a weak mode.
    ```php
    // app/Utils/Encryption.php
    function encrypt_weak($key, $data) {
        $iv = openssl_random_pseudo_bytes(8);
        // DANGEROUS: 'DES-ECB' is broken.
        $ciphertext = openssl_encrypt($data, 'DES-ECB', $key, OPENSSL_RAW_DATA, $iv);
        return $iv . $ciphertext;
    }
    ```

    #### Mitigation and Best Practices
    Always use `Hash::make()` for passwords. For encryption, use Laravel's built-in `Crypt::encryptString()` and `Crypt::decryptString()`. It uses AES-256-CBC or AES-128-CBC with a MAC for integrity. For stronger integrity, consider AES-GCM (requires PHP 7.1+ and OpenSSL extension).

    #### Secure Code Example
    ```php
    // app/Http/Controllers/RegisterController.php (Secure)
    use Illuminate\Support\Facades\Hash;
    
    protected function create(array $data)
    {
        return User::create([
            'name' => $data['name'],
            'email' => $data['email'],
            // SECURE: Uses Laravel's default (bcrypt).
            'password' => Hash::make($data['password']), 
        ]);
    }

    // app/Utils/Encryption.php (Secure using Laravel's Crypt)
    use Illuminate\Support\Facades\Crypt;

    function encrypt_secure($data) {
        // SECURE: Uses AES-CBC with MAC by default.
        return Crypt::encryptString($data);
    }
    
    function decrypt_secure($encrypted_data) {
        return Crypt::decryptString($encrypted_data);
    }
    ```

    #### Testing Strategy
    Check password hashes in the database; they should start with `$2y$` (bcrypt). For encryption, ensure `Crypt::` facade is used or manually check `openssl_encrypt` calls for `AES-256-GCM` or `AES-256-CBC` (and verify MAC is checked on decryption).
  </Tab>
  <Tab title="Node.js">
    #### Framework Context
    Node's built-in `crypto` module offers many algorithms. Vulnerabilities arise from choosing weak ones like `md5`, `sha1`, or weak ciphers like `des`. The popular `bcrypt` library is the standard for passwords.

    #### Vulnerable Scenario 1: Using `crypto.createHash` with MD5/SHA1
    Hashing passwords using the built-in `crypto` module with a weak algorithm.
    ```javascript
    // utils/auth.js
    const crypto = require('crypto');

    function hashPasswordWeak(password) {
      // DANGEROUS: MD5 is broken. SHA1 is also weak.
      return crypto.createHash('md5').update(password).digest('hex');
    }
    ```

    #### Vulnerable Scenario 2: Using Weak Cipher/Mode
    Using `crypto.createCipheriv` with DES or AES in ECB mode.
    ```javascript
    // utils/encryption.js
    const crypto = require('crypto');

    function encryptDesEcb(key, data) {
      // DANGEROUS: 'des-ecb' is broken.
      const cipher = crypto.createCipheriv('des-ecb', key, null); // IV ignored in ECB
      let encrypted = cipher.update(data, 'utf8', 'hex');
      encrypted += cipher.final('hex');
      return encrypted;
    }
    
    function encryptAesEcb(key, data) {
      // DANGEROUS: 'aes-128-ecb' leaks patterns.
      const cipher = crypto.createCipheriv('aes-128-ecb', key, null); 
      // ...
    }
    ```

    #### Mitigation and Best Practices
    Use the `bcrypt` library for password hashing (`bcrypt.hashSync`, `bcrypt.compareSync`). For encryption, use `aes-256-gcm` which provides integrity.

    #### Secure Code Example
    ```javascript
    // utils/auth.js (Secure with bcrypt)
    const bcrypt = require('bcrypt');
    const saltRounds = 12; // Recommended salt rounds

    function hashPasswordSecure(password) {
      // SECURE: Uses bcrypt with a salt
      return bcrypt.hashSync(password, saltRounds);
    }

    function comparePassword(password, hash) {
      return bcrypt.compareSync(password, hash);
    }

    // utils/encryption.js (Secure AES-GCM)
    const crypto = require('crypto');

    function encryptAesGcm(key, data) {
      // SECURE: AES-256-GCM is recommended
      const iv = crypto.randomBytes(12); // 96-bit nonce
      const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);
      
      let encrypted = cipher.update(data, 'utf8', 'hex');
      encrypted += cipher.final('hex');
      const tag = cipher.getAuthTag(); // Get the authentication tag
      
      // Return IV + Tag + Ciphertext for storage/transmission
      return iv.toString('hex') + tag.toString('hex') + encrypted;
    }
    ```

    #### Testing Strategy
    Check password hashes in the database; they should start with `$2b$`. Write unit tests for encryption, ensuring `aes-256-gcm` is specified.
  </Tab>
  <Tab title="Ruby">
    #### Framework Context
    Rails' `has_secure_password` uses bcrypt by default, which is secure. Vulnerabilities occur with manual hashing using `Digest::MD5` or `Digest::SHA1`, or using `OpenSSL::Cipher` with weak algorithms.

    #### Vulnerable Scenario 1: Using `Digest::MD5`
    Manually hashing a password in a model or service.
    ```ruby
    # app/models/user.rb
    require 'digest'

    def password=(new_password)
      # DANGEROUS: MD5 is broken.
      self.password_digest = Digest::MD5.hexdigest(new_password)
    end
    ```

    #### Vulnerable Scenario 2: Using Weak OpenSSL Cipher
    Encrypting data using DES or ECB mode.
    ```ruby
    # lib/encryption.rb
    require 'openssl'

    def encrypt_des_ecb(key, data)
      # DANGEROUS: 'DES-ECB' is broken.
      cipher = OpenSSL::Cipher.new('DES-ECB')
      cipher.encrypt
      cipher.key = key
      # ... encryption logic ...
    end
    ```

    #### Mitigation and Best Practices
    Use `has_secure_password` in your `User` model. For encryption, use `aes-256-gcm` via `OpenSSL::Cipher`.

    #### Secure Code Example
    ```ruby
    # app/models/user.rb (Secure)
    class User < ApplicationRecord
      # SECURE: Uses bcrypt by default.
      has_secure_password 
    end

    # lib/encryption.rb (Secure AES-GCM)
    require 'openssl'

    def encrypt_aes_gcm(key, data)
      # SECURE: AES-256-GCM is recommended.
      cipher = OpenSSL::Cipher.new('aes-256-gcm')
      cipher.encrypt
      cipher.key = key
      iv = cipher.random_iv # Generate random IV/nonce
      cipher.auth_data = "" # Optional additional authenticated data
      
      encrypted = cipher.update(data) + cipher.final
      tag = cipher.auth_tag # Get the authentication tag
      
      # Return IV + Tag + Ciphertext
      { iv: iv, tag: tag, ciphertext: encrypted }
    end
    ```

    #### Testing Strategy
    Check the `password_digest` column in your database; it should start with `$2a$`. Write unit tests for encryption code, asserting the cipher name is `aes-256-gcm`.
  </Tab>
</Tabs>