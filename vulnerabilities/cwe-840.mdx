---
title: "Business Logic Errors"
sidebarTitle: "Business Logic Errors (CWE-840)"
description: "Mitigation for flaws in the application's workflow or business rules that allow unintended actions or data access."
icon: "puzzle-piece"
iconType: "solid"
---

## Overview

Business Logic Errors are flaws in the **design and implementation of an application's workflow** related to its intended function. Unlike technical vulnerabilities (like SQLi or XSS), these flaws exploit **legitimate application processes** in unexpected ways to achieve a malicious goal. Examples include manipulating multi-step processes, abusing feature interactions, or exploiting incorrect assumptions about user behavior or data states. ‚öôÔ∏è‚û°Ô∏è‚ùì‚û°Ô∏èüí∏

---

## Business Impact

Exploiting business logic flaws can lead to significant consequences tailored to the application's purpose:
* **Financial Fraud:** Bypassing payment steps, applying excessive discounts, transferring funds improperly.
* **Unauthorized Access/Action:** Gaining access to features or performing actions reserved for users in a different state (e.g., accessing premium content without paying, approving a request that shouldn't be approvable).
* **Data Manipulation:** Altering application state in unintended ways (e.g., getting negative account balances, submitting orders for unavailable items).
* **Denial of Service:** Exploiting logic that consumes excessive resources under specific conditions.

---

<Card title="Reference Details" icon="book-open" iconType="solid">
  **CWE ID:** [CWE-840](https://cwe.mitre.org/data/definitions/840.html)
  **OWASP Top 10 (2021):** A04:2021 - Insecure Design
  **Severity:** High to Critical (highly context-dependent)
</Card>

---

## Framework-Specific Analysis and Remediation

Business logic flaws are **highly application-specific** and **cannot be prevented solely by framework features**. They require careful design, threat modeling, and robust implementation of the application's rules.

**Key Remediation Principles:**
1.  **Threat Modeling:** Identify potential abuses of workflows during the design phase. Think like an attacker: "How can I misuse this feature?"
2.  **State Management:** Ensure application state transitions are correctly enforced server-side (e.g., an order must be 'pending' before it can be 'shipped').
3.  **Complete Validation:** Validate not just data types, but also business rules (e.g., quantity must be <= available stock, user must be eligible for discount).
4.  **Idempotency:** Ensure that critical actions (like payments) cannot be accidentally or maliciously executed multiple times if a request is replayed.
5.  **Assume Untrusted Input:** Treat all user input, even seemingly benign choices in a workflow, as potentially manipulative. Re-verify critical data server-side at each step.

---

<Tabs>
  <Tab title="Python">
    #### Framework Context
    Flaws in Django views or Flask routes that incorrectly handle application state or workflow steps.

    #### Vulnerable Scenario 1: Discount Abuse
    A discount code is applied, but the server doesn't verify if the code is still valid *at the time of checkout*.
    ```python
    # views/cart.py
    from django.shortcuts import redirect, HttpResponse # Added HttpResponse
    from django.contrib.auth.decorators import login_required # Assuming login needed

    # Assume get_discount, calculate_cart_total, charge_user exist
    # Assume Product model exists

    @login_required
    def apply_discount(request):
        code = request.POST.get('discount_code')
        discount_amount = get_discount(code) # Assume this checks validity *now*
        if discount_amount > 0:
            request.session['discount'] = discount_amount
            request.session['discount_code'] = code # Store code too
        return redirect('view_cart') # Assume 'view_cart' is a valid URL name

    # views/checkout.py
    from decimal import Decimal # For price handling

    @login_required
    def process_checkout(request):
        discount = Decimal(request.session.get('discount', '0.00')) # Ensure Decimal
        cart_total = calculate_cart_total(request.user)
        final_total = cart_total - discount
        # DANGEROUS: The discount code's validity (e.g., expiry, usage limit)
        # is NOT re-checked here. The user could apply a valid code, wait for
        # it to expire or be used up by others, then checkout with the old discount.
        charge_user(request.user, final_total)
        # Need to mark discount code as used *here* too
        # del request.session['discount'] # Forgetting this is also a flaw
        return HttpResponse("Checked out!")
    ```

    #### Vulnerable Scenario 2: Skipping Payment Step
    A multi-step order process allows users to jump directly to the "confirmation" URL without completing the "payment" step.
    ```python
    # views/order.py
    from django.shortcuts import render, redirect # Added render
    from django.http import Http404 # Added Http404
    from .models import Order # Assuming Order model exists

    @login_required
    def payment_step(request, order_id):
        try:
            order = Order.objects.get(pk=order_id, user=request.user)
        except Order.DoesNotExist:
            raise Http404
        # ... process payment form ...
        payment_successful = True # Placeholder for actual payment logic result
        if payment_successful:
            order.status = 'paid'
            order.save()
            request.session['last_paid_order'] = order.id # Mark as paid in session
            return redirect('order_confirmation', order_id=order.id) # Assume URL name
        # ... handle payment failure ...
        return render(request, 'payment_form.html', {'order': order}) # Example render


    @login_required
    def confirmation_step(request, order_id):
        # DANGEROUS: Only checks if the user owns the order,
        # not if the order status is actually 'paid'.
        # Attacker navigates directly to /order/confirm/123 after creating order, skipping payment.
        try:
             order = Order.objects.get(pk=order_id, user=request.user)
             # Should check order.status here!
             # if order.status != 'paid': return redirect('order_error')
             return render(request, 'confirmation.html', {'order': order})
        except Order.DoesNotExist:
             raise Http404
    ```

    #### Mitigation and Best Practices
    * Re-validate all conditions, prices, discounts, and eligibility server-side *at the point of final action* (e.g., checkout, order placement).
    * Enforce strict state transitions (e.g., use a state machine pattern). Check the object's current state before allowing the next step in a workflow.

    #### Secure Code Example
    ```python
    # views/checkout.py (Secure Discount)
    from django.contrib import messages # For user feedback

    @login_required
    def process_checkout_secure(request):
        discount_code = request.session.get('discount_code')
        cart_total = calculate_cart_total(request.user)
        final_total = cart_total
        discount_amount_applied = Decimal('0.00') # Track applied discount

        if discount_code:
            # SECURE: Re-validate discount code validity *at checkout time*.
            # Assume check_and_use_discount marks code as used atomically if valid
            is_valid, discount_amount = check_and_use_discount(discount_code, request.user, cart_total)
            if is_valid:
                final_total -= discount_amount
                discount_amount_applied = discount_amount # Store amount for potential rollback
            else:
                 messages.warning(request, f"Discount code '{discount_code}' is no longer valid.")
                 del request.session['discount_code'] # Remove invalid code

        try:
            charge_user(request.user, final_total)
            # Clear discount from session after successful charge
            if 'discount_code' in request.session: del request.session['discount_code']
            return HttpResponse("Checked out!")
        except Exception as e: # Catch specific PaymentFailedError if defined
             # If charge fails, maybe revert discount usage status? (Complex logic needed)
             # if discount_amount_applied > 0:
             #     revert_discount_usage(discount_code, request.user)
             messages.error(request, "Payment failed.")
             return redirect('checkout_page') # Redirect back to try again

    # views/order.py (Secure Confirmation Step)
    @login_required
    def confirmation_step_secure(request, order_id):
        try:
             order = Order.objects.get(pk=order_id, user=request.user)
             # SECURE: Check the authoritative state from the database.
             if order.status != 'paid':
                  messages.error(request, "Order payment not completed.")
                  return redirect('order_payment', order_id=order.id) # Redirect back
             return render(request, 'confirmation.html', {'order': order})
        except Order.DoesNotExist:
             raise Http404
    ```

    #### Testing Strategy
    Thoroughly map out application workflows. For each step, identify the required state and data. Attempt to:
    * Skip steps (e.g., browse directly to later URLs).
    * Replay requests for actions that should only happen once (e.g., submitting payment multiple times).
    * Manipulate parameters to trigger edge cases (e.g., negative quantities, future dates).
    * Perform actions out of sequence or when prerequisites aren't met (e.g., apply expired discount).
    This often requires manual, context-aware testing.
  </Tab>
  <Tab title="Java">
    #### Framework Context
    Flaws in Controllers or Services that don't correctly manage state transitions or re-validate business rules.

    #### Vulnerable Scenario 1: Price Check Only on Add-to-Cart
    The price of an item is checked when added to the cart, but not re-checked at checkout.
    ```java
    // service/CartService.java - Assuming ProductRepo, CartRepo, CartItem, Product exist
    // @Autowired ProductRepository productRepo;
    // @Autowired CartRepository cartRepo;
    public void addToCart(String userId, String productId, int quantity) {
        Product p = productRepo.findById(productId).orElseThrow();
        // Price is correct when added
        cartRepo.addItem(userId, productId, quantity, p.getPrice()); // Assumes CartRepo handles CartItem creation
    }

    // controller/CheckoutController.java - Assume Cart, CartItem, CartRepo, PaymentService exist
    // @Autowired CartRepository cartRepo;
    // @Autowired PaymentService paymentService;
    @PostMapping("/checkout")
    public String checkout(Principal principal) {
        String userId = principal.getName();
        Cart cart = cartRepo.findByUserId(userId); // Assumes method exists
        BigDecimal total = BigDecimal.ZERO;
        // DANGEROUS: Calculates total based on prices stored in the cart session/DB
        // *when items were added*. Prices might have changed since then.
        for (CartItem item : cart.getItems()) { // Assumes getItems() exists
            // Assumes getPriceAtAddition() exists
            total = total.add(item.getPriceAtAddition().multiply(BigDecimal.valueOf(item.getQuantity())));
        }
        paymentService.charge(userId, total); // Charges potentially outdated total
        // ... clear cart ...
        return "confirmation"; // View name
    }
    ```

    #### Vulnerable Scenario 2: Workflow Bypass via Parameter Manipulation
    An approval workflow requires manager approval, but the "approve" endpoint accepts an `isManagerApproved=true` parameter that the server trusts.
    ```java
    // controller/WorkflowController.java - Assume RequestData, WorkflowService, WorkflowRequest, WorkflowRepo exist
    import org.springframework.security.access.prepost.PreAuthorize;
    import org.springframework.web.bind.annotation.*;
    import java.security.Principal;
    // ... other imports ...

    @PostMapping("/submit-request")
    public String submitRequest(@ModelAttribute RequestData data, Principal principal) {
        // ... save initial request, status = 'PENDING_APPROVAL' ...
        workflowService.createRequest(data, principal.getName());
        return "redirect:/requests";
    }

    // This endpoint should ideally only be callable by manager,
    // BUT even if it is, it might trust a parameter sent by client.
    @PostMapping("/approve-request/{id}")
    @PreAuthorize("hasRole('MANAGER')") // Checks manager role
    public String approveRequest(@PathVariable long id, @RequestParam(required=false, defaultValue="false") boolean forceApprove) {
        // DANGEROUS: A manager calls this, but if 'forceApprove=true' is submitted
        // (maybe via dev tools on a hidden field), it bypasses normal checks.
        // The business logic flaw is trusting this flag instead of re-validating conditions.
        WorkflowRequest req = workflowRepo.findById(id).orElseThrow();
        if (forceApprove || workflowService.checkApprovalConditions(req)) { // Bypasses checks
            req.setStatus("APPROVED"); // Assumes setStatus exists
            workflowRepo.save(req);
        } else {
             // Handle condition failure
        }
        return "redirect:/requests";
    }
    ```

    #### Mitigation and Best Practices
    * **Data Freshness:** Always retrieve authoritative data (prices, stock levels, user roles, object status) from the database immediately before performing critical actions. Do not rely on data stored in sessions or submitted by the client if it might be stale or tampered with.
    * **Server Authority:** Do not trust parameters submitted by the client to indicate state or bypass checks (`forceApprove`). Re-evaluate all conditions server-side based on authoritative data.
    * **State Enforcement:** Explicitly check the current state of an object before allowing state transitions (e.g., `if (order.getStatus() != OrderStatus.PENDING) { throw new IllegalStateException(...); }`).

    #### Secure Code Example
    ```java
    // controller/CheckoutController.java (Secure Price Check)
    // Assume ProductRepository exists
    // @Autowired ProductRepository productRepo;

    @PostMapping("/checkout-secure")
    public String checkoutSecure(Principal principal) {
        String userId = principal.getName();
        Cart cart = cartRepo.findByUserId(userId);
        BigDecimal authoritativeTotal = BigDecimal.ZERO;

        // SECURE: Iterate cart items but fetch CURRENT price from product DB for calculation.
        for (CartItem item : cart.getItems()) {
            Product currentProduct = productRepo.findById(item.getProductId()).orElseThrow(/* appropriate exception */);
            authoritativeTotal = authoritativeTotal.add(
                currentProduct.getPrice().multiply(BigDecimal.valueOf(item.getQuantity()))
            );
            // Optional: Check stock levels here too
        }
        paymentService.charge(userId, authoritativeTotal); // Charges correct, current total
        // ... clear cart ...
        return "confirmation";
    }

    // controller/WorkflowController.java (Secure Approval)
    @PostMapping("/approve-request-secure/{id}")
    @PreAuthorize("hasRole('MANAGER')")
    public String approveRequestSecure(@PathVariable long id /* Removed forceApprove param */) {
        WorkflowRequest req = workflowRepo.findById(id).orElseThrow();
        // SECURE: Always re-validate conditions on the server. Do not trust client flags.
        if (workflowService.checkApprovalConditions(req)) { // Assumes this method exists
            // SECURE: Only proceed if server-side conditions are met.
            req.setStatus("APPROVED");
            workflowRepo.save(req);
        } else {
             // Handle condition failure (e.g., return error message)
             return "redirect:/requests?error=conditions_not_met";
        }
        return "redirect:/requests";
    }
    ```

    #### Testing Strategy
    Map application workflows. Identify key data and state checks.
    * **Stale Data:** Add an item to cart, wait (simulate price change), checkout. Does it use the old or new price?
    * **State Bypass:** Try accessing step 3 URL before completing step 2. Try approving an item that is already rejected.
    * **Parameter Tampering:** Modify hidden fields or parameters related to workflow state or conditions (`isApproved`, `status`, discount codes) and see if the server accepts them.
    * **Race Conditions:** Try submitting duplicate requests rapidly for actions that should only occur once (e.g., using Burp Intruder).
  </Tab>
  <Tab title=".NET(C#)">
    #### Framework Context
    Flaws in Controller Actions or PageModel Handlers not correctly validating state or business rules before executing actions.

    #### Vulnerable Scenario 1: Re-using a One-Time Token
    A password reset link uses a token, but the token isn't invalidated after the first successful use.
    ```csharp
    // Controllers/AccountController.cs - Assume ResetPasswordViewModel, _context, _userManager exist
    using Microsoft.AspNetCore.Mvc; // Added for attributes, IActionResult etc.
    using Microsoft.AspNetCore.Identity; // Added for UserManager
    using Microsoft.EntityFrameworkCore; // Added for FirstOrDefaultAsync
    using System; // Added for DateTime
    using System.Threading.Tasks; // Added for Task
    // Assume ApplicationDbContext _context, UserManager<IdentityUser> _userManager injected
    // Assume ResetPasswordViewModel has Token, NewPassword, Email properties
    // Assume User model has PasswordResetToken, PasswordResetTokenExpiry properties

    [HttpPost("reset-password")]
    public async Task<IActionResult> ResetPassword(ResetPasswordViewModel model)
    {
        // DANGEROUS: Finds user by token, but doesn't check if token has already been used.
        // Attacker could intercept the reset email, let the user reset,
        // then use the same token again later to set their own password.
        // Also, finding user by token might leak info if token is guessable. Better to find by email/ID.
        var user = await _context.Users.FirstOrDefaultAsync(u => u.PasswordResetToken == model.Token && u.PasswordResetTokenExpiry > DateTime.UtcNow);
        if (user != null)
        {
            // Reset password logic using UserManager is preferred as it handles token validation/invalidation
            var resetResult = await _userManager.ResetPasswordAsync(user, model.Token, model.NewPassword);
            // FORGOTTEN STEP (if ResetPasswordAsync doesn't invalidate or if custom token logic):
            // user.PasswordResetToken = null; // Invalidate the token in the DB
            // await _context.SaveChangesAsync();
            if (resetResult.Succeeded) {
                 return RedirectToAction("ResetSuccess"); // Assume ResetSuccess action exists
            } else {
                 // Add errors to model state
                 foreach(var error in resetResult.Errors) { ModelState.AddModelError(string.Empty, error.Description); }
            }
        } else {
            ModelState.AddModelError(string.Empty, "Invalid or expired token.");
        }
        // Handle invalid token or Identity errors
        return View(model); // Return view with model to show errors
    }
    ```

    #### Vulnerable Scenario 2: Modifying Quantity Below Minimum Order
    Business rule requires minimum order quantity of 5, enforced client-side only.
    ```csharp
    // Pages/ProductPage.cshtml.cs - Assume _context, _cartService exist, PageModel structure
    using Microsoft.AspNetCore.Mvc; // For PageModel, IActionResult etc.
    using Microsoft.AspNetCore.Mvc.RazorPages; // For PageModel
    using System.ComponentModel.DataAnnotations; // For Range
    using System.Threading.Tasks; // For Task
    // Assume ApplicationDbContext _context, CartService _cartService injected
    // Assume Product model exists

    // Bind properties for GET and POST
    [BindProperties(SupportsGet = true)]
    public class ProductPageModel : PageModel
    {
        // ... (Inject context, service) ...
        public Product Product { get; set; } // Property for product details
        public int ProductId { get; set;} // Bound from route/query

        [BindProperty] // Only bind this on POST
        public int InputQuantity { get; set;}

        public async Task OnGetAsync(int productId) {
             ProductId = productId;
             Product = await _context.Products.FindAsync(productId);
             // Handle product not found
        }

        public async Task<IActionResult> OnPostAsync() // Renamed from example
        {
            // DANGEROUS: Server trusts the submitted quantity.
            // Attacker uses dev tools to change quantity to 1 before submitting.
            // Business rule (min 5) is bypassed because it's only checked client-side.
            if (InputQuantity <= 0) { // Basic check, but not the business rule
                ModelState.AddModelError(nameof(InputQuantity), "Quantity must be positive.");
                // Need to reload product for the Page() return if validation fails
                Product = await _context.Products.FindAsync(ProductId);
                return Page();
            }

            var product = await _context.Products.FindAsync(ProductId);
            if (product == null) return NotFound();
            // ... add 'InputQuantity' of 'product' to cart ...
            _cartService.AddItem(product, InputQuantity); // Adds only 1 item

            return RedirectToPage("/Cart");
        }
    }
    ```

    #### Mitigation and Best Practices
    * **State Management:** Ensure state transitions are atomic and correctly enforced. Invalidate tokens immediately after use (Identity's default `ResetPasswordAsync` *should* do this if using its token provider). Check current object status before allowing actions.
    * **Server-Side Validation:** Re-validate all business rules (minimum quantities, user eligibility, etc.) on the server, even if checked client-side. Use validation attributes or explicit checks in the handler/action.

    #### Secure Code Example
    ```csharp
    // Controllers/AccountController.cs (Secure Token Invalidation)
    [HttpPost("reset-password")]
    public async Task<IActionResult> ResetPassword(ResetPasswordViewModel model)
    {
        // SECURE: Rely on Identity's ResetPasswordAsync to validate AND invalidate the token.
        // Find user by email or ID from the model, not by token directly.
        var user = await _userManager.FindByEmailAsync(model.Email); // Assuming email is in ViewModel
        if (user != null)
        {
            // ResetPasswordAsync validates the token against the user and purpose,
            // and invalidates it upon success (if using default provider).
            var result = await _userManager.ResetPasswordAsync(user, model.Token, model.NewPassword);
            if (result.Succeeded)
            {
                // If using custom token logic, manually invalidate here:
                // user.PasswordResetToken = null;
                // user.PasswordResetTokenExpiry = null;
                // await _userManager.UpdateAsync(user); // Use UserManager or _context.SaveChangesAsync()
                return RedirectToAction("ResetSuccess");
            }
            // Handle Identity errors
            foreach (var error in result.Errors) { ModelState.AddModelError(string.Empty, error.Description); }
        }
        else { ModelState.AddModelError(string.Empty, "Invalid user or token."); }
        // Handle invalid/expired token or user not found
        return View(model);
    }

    // Pages/ProductPage.cshtml.cs (Secure Quantity Check)
    public class ProductPageModelSecure : PageModel
    {
        // ... (Inject context, service) ...
        [BindProperty(SupportsGet = true)]
        public int ProductId { get; set;}
        public Product Product { get; set; }

        // SECURE: Apply Range validation attribute server-side.
        [BindProperty]
        [Range(5, 100, ErrorMessage = "Quantity must be between 5 and 100.")]
        public int InputQuantity { get; set;}

         public async Task OnGetAsync(int productId) {
             ProductId = productId;
             Product = await _context.Products.FindAsync(productId);
             // Handle not found
             if (Product == null) RedirectToPage("/NotFound"); // Example
        }


        public async Task<IActionResult> OnPostAsync() // Renamed from example
        {
            // SECURE: ModelState.IsValid checks the [Range] attribute.
            if (!ModelState.IsValid)
            {
                // Reload product info needed for the page model if validation fails
                Product = await _context.Products.FindAsync(ProductId);
                if (Product == null) return NotFound(); // Check again
                return Page(); // Return page with validation errors
            }

            var product = await _context.Products.FindAsync(ProductId);
            if (product == null) return NotFound(); // Check product exists
            _cartService.AddItem(product, InputQuantity); // Adds valid quantity

            return RedirectToPage("/Cart");
        }
    }
    ```

    #### Testing Strategy
    Map workflows.
    * **Token Reuse:** Try using a password reset or email verification link multiple times. Does it work after the first successful use?
    * **State Bypass:** Try accessing URLs or submitting forms related to later steps in a process before completing earlier ones.
    * **Business Rule Bypass:** Modify client-side values (quantities, amounts) to violate known business rules (minimums, maximums, eligibility) and submit. Does the server catch the violation (check `ModelState.IsValid`)?
  </Tab>
  <Tab title="PHP">
    #### Framework Context
    Flaws in Controller logic or Services that fail to validate state transitions or business rules defined by the application.

    #### Vulnerable Scenario 1: Applying Coupon Multiple Times
    A coupon can be applied, reducing the cart total, but there's no check to prevent applying it repeatedly.
    ```php
    // app/Http/Controllers/CartController.php
    use Illuminate\Http\Request;
    use App\Models\Coupon; // Assuming Coupon model
    use Illuminate\Support\Facades\Redirect; // Use facade for redirect

    public function applyCoupon(Request $request) {
        $couponCode = $request->input('coupon_code');
        $coupon = Coupon::where('code', $couponCode)->first();

        if ($coupon && $coupon->isValid()) { // Assume isValid checks date, maybe uses remaining
            $cart = $request->session()->get('cart'); // Example: getting cart from session
            if ($cart) { // Check if cart exists
                 $cart->applyDiscount($coupon->discount_amount); // Assumes method exists on cart object
                 // DANGEROUS: Doesn't prevent applying the same (or different) coupon again.
                 // Also, coupon validity (e.g., uses left) should be rechecked *during checkout*.
                 $request->session()->put('cart', $cart); // Save cart back to session
                 session()->flash('message', 'Coupon applied!');
            } else {
                 session()->flash('error', 'Cart not found.');
            }
        } else {
            session()->flash('error', 'Invalid coupon code.');
        }
        return Redirect::route('cart.show'); // Assume route exists
    }
    ```

    #### Vulnerable Scenario 2: Bypassing Survey Completion for Reward
    Users get a reward after completing a survey, but the reward endpoint only checks if the survey *exists*, not if it's *completed*.
    ```php
    // app/Http/Controllers/SurveyController.php
    use App\Models\Survey; // Added import
    use App\Models\User; // Added import
    use Illuminate\Http\Request;
    use Illuminate\Support\Facades\Redirect; // Use facade

    public function claimReward(Request $request, Survey $survey) {
        // Assume route model binding finds the survey by ID
        $user = auth()->user();

        // DANGEROUS: Only checks if user owns the survey record.
        // Doesn't check survey->is_completed flag or similar status.
        // Attacker starts survey, gets the survey ID, then browses here.
        if ($survey->user_id !== $user->id) { abort(403); }

        // Give reward without checking completion status
        $user->addRewardPoints(100); // Assumes this method exists
        $survey->reward_claimed = true; // Marks claimed, but completion wasn't checked
        $survey->save();

        return Redirect::route('rewards.index'); // Assume rewards.index exists
    }
    ```

    #### Mitigation and Best Practices
    * **State Tracking:** Add flags or status fields to models (e.g., `coupon_applied_to_cart_id`, `survey_completed_at`, `reward_claimed_at`) and check these flags before allowing actions.
    * **Re-validation at Critical Points:** Re-verify coupon validity, eligibility, and single-use constraints during the final checkout process. Check survey completion status before granting rewards.

    #### Secure Code Example
    ```php
    // app/Http/Controllers/CartController.php (Secure Coupon Application)
    public function applyCoupon(Request $request) {
        $couponCode = $request->input('coupon_code');
        $coupon = Coupon::where('code', $couponCode)->first();
        $cart = $request->session()->get('cart'); // Example: getting cart

        if (!$cart) {
             session()->flash('error', 'Cart not found.');
             return Redirect::route('cart.show');
        }

        // SECURE: Check if a coupon is already applied to this cart.
        if ($cart->coupon_applied_id !== null) { // Assume cart object has this property
            session()->flash('error', 'Only one coupon per order.');
            return Redirect::route('cart.show');
        }

        // Assume isValidForCart checks date, uses remaining, and cart applicability
        if ($coupon && $coupon->isValidForCart($cart)) {
            $cart->applyDiscount($coupon->discount_amount);
            $cart->coupon_applied_id = $coupon->id; // Mark coupon as applied to THIS cart
            $request->session()->put('cart', $cart); // Save updated cart
            session()->flash('message', 'Coupon applied!');
        } else {
            session()->flash('error', 'Invalid or inapplicable coupon code.');
        }
        return Redirect::route('cart.show');
        // NOTE: Final validation should still happen during checkout.
    }

    // app/Http/Controllers/SurveyController.php (Secure Reward Claim)
    public function claimReward(Request $request, Survey $survey) {
        $user = auth()->user();
        if ($survey->user_id !== $user->id) { abort(403); }

        // SECURE: Check survey completion status.
        if (!$survey->is_completed) { // Assume is_completed is a boolean field
             session()->flash('error', 'Survey not completed yet.');
             return Redirect::route('survey.show', $survey); // Assume survey.show exists
        }
        // SECURE: Check if reward already claimed.
        if ($survey->reward_claimed) {
            session()->flash('error', 'Reward already claimed for this survey.');
            return Redirect::route('rewards.index');
        }

        // Give reward only if checks pass
        $user->addRewardPoints(100);
        $survey->reward_claimed = true;
        $survey->save();

        return Redirect::route('rewards.index');
    }
    ```

    #### Testing Strategy
    Map application workflows.
    * **Replay Actions:** Try applying a coupon twice. Try claiming a reward twice.
    * **State Bypass:** Access reward URL before completing the survey. Access checkout confirmation before paying.
    * **Concurrency:** Use tools (Burp Intruder with multiple threads) to submit requests simultaneously (e.g., two requests to use a single-use coupon). Does the application correctly prevent double-spending/double-action?
    Manual testing and careful code review are crucial.
  </Tab>
  <Tab title="Node.js">
    #### Framework Context
    Flaws in Express route handlers or service logic that fail to manage state transitions correctly or re-verify business rules.

    #### Vulnerable Scenario 1: Voting Multiple Times
    An API endpoint allows voting but only checks if the user *has ever* voted, not if they are voting *again* within the allowed period.
    ```javascript
    // routes/poll.js - Assume VoteService, ensureAuthenticated exist
    // const VoteService = require('../services/voteService'); // Example import
    // const ensureAuthenticated = require('../middleware/auth'); // Example import
    // const router = require('express').Router(); // Example router setup

    router.post('/:pollId/vote', ensureAuthenticated, async (req, res) => {
        const { pollId } = req.params;
        const { optionId } = req.body;
        const userId = req.user.id; // Assume user is attached by middleware

        try {
            const hasVoted = await VoteService.checkIfUserVoted(userId, pollId); // Assumes method exists
            // DANGEROUS: Simple boolean check. If the user votes, then tries again
            // immediately (e.g., race condition, replayed request), this check might
            // still pass if the vote hasn't fully registered yet, or if the check
            // logic only prevents voting if a vote *already exists*.
            if (hasVoted) {
                return res.status(400).send('Already voted.');
            }

            // Record the vote
            await VoteService.recordVote(userId, pollId, optionId); // Assumes method exists
            res.send('Vote recorded.');
        } catch (err) {
            console.error("Voting error:", err); // Log error
            res.status(500).send('Error.');
        }
    });
    ```

    #### Vulnerable Scenario 2: Adding Item After Order Finalized
    An endpoint to add items to a cart doesn't check if the cart/order has already been submitted or paid for.
    ```javascript
    // routes/cart.js - Assume CartService, ensureAuthenticated exist
    router.post('/items', ensureAuthenticated, async (req, res) => {
        const { cartId, productId, quantity } = req.body; // Assuming cartId is known
        const userId = req.user.id;

        try {
             // DANGEROUS: Fetches cart but doesn't check its status.
             // Attacker could submit this request *after* payment for 'cartId' is complete.
             const cart = await CartService.getCart(cartId, userId); // Assume this checks ownership & exists
             if (!cart) return res.status(404).send('Cart not found.');

             // Logic to add item... proceeds even if cart.status is 'PAID' or 'SUBMITTED'
             await CartService.addItem(cartId, productId, quantity); // Assumes method exists
             res.send('Item added.');

        } catch (err) {
             console.error("Add item error:", err); // Log error
             res.status(500).send('Error.');
        }
    });
    ```

    #### Mitigation and Best Practices
    * **Atomicity/Locking:** Use database transactions or atomic operations (like `findOneAndUpdate` with checks, or locking) to prevent race conditions in actions like voting or using limited resources.
    * **State Validation:** Always check the current state of the relevant object (cart status, order status, vote status) before performing an action that depends on a specific state.

    #### Secure Code Example
    ```javascript
    // routes/poll.js (Secure - using DB constraints or atomic update)
    // Assume VoteService.recordVoteAtomically uses DB unique constraint or atomic update
    router.post('/:pollId/vote-secure', ensureAuthenticated, async (req, res) => {
        const { pollId } = req.params;
        const { optionId } = req.body;
        const userId = req.user.id;
        try {
            // SECURE: Attempt to record vote using a method that includes atomicity.
            // This method should return true on success, false if vote already exists.
            const voteRecorded = await VoteService.recordVoteAtomically(userId, pollId, optionId);

            if (voteRecorded) {
                res.send('Vote recorded.');
            } else {
                // This means the unique constraint failed or atomic update found existing vote
                res.status(400).send('Already voted or invalid poll.');
            }
        } catch (err) {
             // Handle DB errors etc.
             console.error("Vote recording error:", err);
             res.status(500).send('Error recording vote.');
        }
    });

    // routes/cart.js (Secure - Check Status)
    router.post('/items-secure', ensureAuthenticated, async (req, res) => {
        const { cartId, productId, quantity } = req.body;
        const userId = req.user.id;
        try {
             const cart = await CartService.getCart(cartId, userId);
             if (!cart) return res.status(404).send('Cart not found.');

             // SECURE: Check the cart's status before allowing modification.
             if (cart.status !== 'ACTIVE') { // Assuming 'ACTIVE' is the modifiable status
                  return res.status(400).send('Cart is not active and cannot be modified.');
             }

             await CartService.addItem(cartId, productId, quantity);
             res.send('Item added.');

        } catch (err) {
            console.error("Add item error:", err);
            res.status(500).send('Error adding item.');
        }
    });
    ```

    #### Testing Strategy
    Map workflows.
    * **Race Conditions:** Use an intercepting proxy (Burp Intruder) to send multiple identical requests (e.g., to vote, claim reward, use coupon) nearly simultaneously. Check if the action is performed more than once.
    * **State Bypass:** Identify objects with status fields (Cart, Order, Survey). Try performing actions only valid for one status when the object is in a different status (e.g., add item to 'PAID' cart, claim reward for 'IN_PROGRESS' survey).
    Manual testing and understanding the intended logic are crucial.
  </Tab>
  <Tab title="Ruby">
    #### Framework Context
    Flaws in Controller actions or Models that don't enforce state transitions or re-verify business conditions.

    #### Vulnerable Scenario 1: Transferring More Funds Than Available
    A bank transfer function checks the balance initially but doesn't use locking, allowing a race condition.
    ```ruby
    # app/controllers/transfers_controller.rb - Assume User model has balance, BigDecimal loaded
    class TransfersController < ApplicationController
      before_action :authenticate_user! # Assume Devise or similar

      def create
        amount = BigDecimal(params[:amount])
        recipient = User.find(params[:recipient_id])
        sender = current_user

        # DANGEROUS: Balance checked outside of transaction lock.
        if sender.balance >= amount && amount > 0
          # Attacker sends two simultaneous requests for $100 when balance is $100.
          # Both might pass this check before either transaction completes.
          ActiveRecord::Base.transaction do
            # Reloading inside transaction might still race if not locked
            # sender.reload
            # recipient.reload
            sender.balance -= amount
            recipient.balance += amount
            sender.save!
            recipient.save!
          end
          redirect_to root_path, notice: "Transfer successful."
        else
          redirect_to root_path, alert: "Insufficient funds or invalid amount."
        end
      rescue ActiveRecord::RecordNotFound
          redirect_to root_path, alert: "Recipient not found."
      rescue ArgumentError # Handle invalid BigDecimal
          redirect_to root_path, alert: "Invalid amount."
      end
    end
    ```

    #### Vulnerable Scenario 2: Modifying Finalized Record
    Allowing edits to an invoice after it has been marked as 'paid'.
    ```ruby
    # app/controllers/invoices_controller.rb - Assume Invoice model has status
    class InvoicesController < ApplicationController
      before_action :authenticate_user! # Added auth
      before_action :set_invoice # Assume this finds @invoice via current_user.invoices.find

      def update
        # DANGEROUS: Does not check invoice status before allowing update.
        # Attacker could change items/amount on an already paid invoice.
        if @invoice.update(invoice_params)
           redirect_to @invoice, notice: 'Invoice updated.'
        else
           render :edit # Assume edit action exists
        end
      end

      private
      def set_invoice
        @invoice = current_user.invoices.find(params[:id]) # Scope to user
      rescue ActiveRecord::RecordNotFound
        redirect_to invoices_path, alert: "Invoice not found." # Assume invoices_path exists
      end

      def invoice_params
         # Ensure permitted params are safe and don't allow changing status here
         params.require(:invoice).permit(:due_date, :amount /* etc */)
      end
    end
    ```

    #### Mitigation and Best Practices
    * **Locking/Atomicity:** Use pessimistic locking (`sender.lock!`) within the transaction to prevent race conditions during balance checks and updates. Or use atomic database updates (`User.update_counters`, `decrement!`).
    * **State Validation:** Check the object's state *before* performing actions (`unless @invoice.is_editable? ...`). Use state machine gems (`aasm`) to enforce valid transitions.

    #### Secure Code Example
    ```ruby
    # app/controllers/transfers_controller.rb (Secure - Pessimistic Locking)
    class TransfersController < ApplicationController
      before_action :authenticate_user!

      def create
        amount = BigDecimal(params[:amount])
        recipient = User.find(params[:recipient_id])
        sender = current_user

        # SECURE: Perform check and update within a transaction with locking.
        ActiveRecord::Base.transaction do
          # Lock rows in a consistent order to prevent deadlocks (e.g., by ID)
          users_to_lock = [sender, recipient].sort_by(&:id)
          users_to_lock.first.lock!
          users_to_lock.second.lock!

          # Re-check balance *after* acquiring lock
          # Reloading might be needed if attributes changed before lock
          # sender.reload
          if sender.balance >= amount && amount > 0
            sender.balance -= amount
            recipient.balance += amount
            # Use save! to raise exception on validation failure inside transaction
            sender.save!
            recipient.save!
          else
            # Raise exception to rollback transaction and show error
            raise ActiveRecord::Rollback, "Insufficient funds or invalid amount."
          end
        end
        redirect_to root_path, notice: "Transfer successful."
      rescue ActiveRecord::Rollback => e
        redirect_to root_path, alert: e.message
      rescue ActiveRecord::RecordNotFound
          redirect_to root_path, alert: "Recipient not found."
      rescue ArgumentError
          redirect_to root_path, alert: "Invalid amount."
      end
    end

    # app/controllers/invoices_controller.rb (Secure - State Check)
    class InvoicesController < ApplicationController
      before_action :authenticate_user!
      before_action :set_invoice
      # SECURE: Add a check before the update action
      before_action :check_if_editable, only: [:edit, :update] # Check before showing edit form too

      def edit # Added edit action example
         # If check_if_editable passes, render form
         render :edit
      end

      def update
        # State already checked by before_action
        if @invoice.update(invoice_params)
           redirect_to @invoice, notice: 'Invoice updated.'
        else
           render :edit
        end
      end

      private
      def set_invoice
        @invoice = current_user.invoices.find(params[:id])
      rescue ActiveRecord::RecordNotFound
        redirect_to invoices_path, alert: "Invoice not found."
      end

      def check_if_editable
        # Assume Invoice model has statuses like 'draft', 'sent', 'paid'
        unless @invoice.status == 'draft' # Or whatever editable status is
           redirect_to @invoice, alert: "Cannot edit an invoice that is not in draft status."
        end
      end

      def invoice_params
         params.require(:invoice).permit(:due_date, :amount /* etc */)
      end
    end
    ```

    #### Testing Strategy
    Map workflows.
    * **Race Conditions:** Use tools (Burp Intruder, custom scripts with threads) to send simultaneous requests for balance-dependent actions (transfers, withdrawals) or actions consuming limited resources (claiming unique coupon). Verify only one succeeds or balance remains correct.
    * **State Bypass:** Attempt to perform actions on objects in the wrong state (e.g., edit a 'paid' invoice, ship a 'cancelled' order). Verify the action is denied based on server-side state checks (`before_action`, model validations, state machine).
  </Tab>
</Tabs>