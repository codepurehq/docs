---
title: "Business Logic Errors"
sidebarTitle: "Business Logic Errors (CWE-840)"
description: "Mitigation for flaws in the application's workflow or business rules that allow unintended actions or data access."
icon: "puzzle-piece"
iconType: "solid"
---

## Overview

Business Logic Errors are flaws in the **design and implementation of an application's workflow** related to its intended function. Unlike technical vulnerabilities (like SQLi or XSS), these flaws exploit **legitimate application processes** in unexpected ways to achieve a malicious goal. Examples include manipulating multi-step processes, abusing feature interactions, or exploiting incorrect assumptions about user behavior or data states.

## Business Impact

Exploiting business logic flaws can lead to significant consequences tailored to the application's purpose:
* **Financial Fraud:** Bypassing payment steps, applying excessive discounts, transferring funds improperly.
* **Unauthorized Access/Action:** Gaining access to features or performing actions reserved for users in a different state (e.g., accessing premium content without paying, approving a request that shouldn't be approvable).
* **Data Manipulation:** Altering application state in unintended ways (e.g., getting negative account balances, submitting orders for unavailable items).
* **Denial of Service:** Exploiting logic that consumes excessive resources under specific conditions.

<Card title="Reference Details" icon="book-open" iconType="solid">
  **CWE ID:** [CWE-840](https://cwe.mitre.org/data/definitions/840.html)
  **OWASP Top 10 (2021):** A04:2021 - Insecure Design
  **Severity:** High to Critical (highly context-dependent)
</Card>

## Framework-Specific Analysis and Remediation

Business logic flaws are **highly application-specific** and **cannot be prevented solely by framework features**. They require careful design, threat modeling, and robust implementation of the application's rules.

**Key Remediation Principles:**
1.  **Threat Modeling:** Identify potential abuses of workflows during the design phase. Think like an attacker: "How can I misuse this feature?"
2.  **State Management:** Ensure application state transitions are correctly enforced server-side (e.g., an order must be 'pending' before it can be 'shipped').
3.  **Complete Validation:** Validate not just data types, but also business rules (e.g., quantity must be <= available stock, user must be eligible for discount).
4.  **Idempotency:** Ensure that critical actions (like payments) cannot be accidentally or maliciously executed multiple times if a request is replayed.
5.  **Assume Untrusted Input:** Treat all user input, even seemingly benign choices in a workflow, as potentially manipulative. Re-verify critical data server-side at each step.

<Tabs>
  <Tab title="Python">
    #### Framework Context
    Flaws in Django views or Flask routes that incorrectly handle application state or workflow steps.

    #### Vulnerable Scenario 1: Discount Abuse
    A discount code is applied, but the server doesn't verify if the code is still valid *at the time of checkout*.
    ```python
    # views/cart.py
    from django.shortcuts import redirect, HttpResponse
    from django.contrib.auth.decorators import login_required
    from decimal import Decimal

    # Assume get_discount, calculate_cart_total, charge_user exist

    @login_required
    def apply_discount(request):
        code = request.POST.get('discount_code')
        discount_amount = get_discount(code) # Assume this checks validity *now*
        if discount_amount > 0:
            request.session['discount_code'] = code # Store code
        return redirect('view_cart') # Assume 'view_cart' is a valid URL name

    # views/checkout.py
    @login_required
    def process_checkout(request):
        discount_code = request.session.get('discount_code')
        cart_total = calculate_cart_total(request.user)
        discount = get_discount(discount_code) # Re-fetch, but check validity?

        # DANGEROUS: The discount code's validity (e.g., expiry, usage limit)
        # is NOT re-checked here, or is checked using stale data.
        final_total = cart_total - discount
        charge_user(request.user, final_total)
        return HttpResponse("Checked out!")
    ```

    #### Vulnerable Scenario 2: Skipping Payment Step
    A multi-step order process allows users to jump directly to the "confirmation" URL without completing the "payment" step.
    ```python
    # views/order.py
    from django.shortcuts import render, redirect
    from django.http import Http404
    from .models import Order # Assuming Order model exists

    @login_required
    def payment_step(request, order_id):
        try:
            order = Order.objects.get(pk=order_id, user=request.user)
        except Order.DoesNotExist:
            raise Http404
        # ... process payment form ...
        payment_successful = True # Placeholder
        if payment_successful:
            order.status = 'paid'
            order.save()
            return redirect('order_confirmation', order_id=order.id)
        return render(request, 'payment_form.html', {'order': order})


    @login_required
    def confirmation_step(request, order_id):
        # DANGEROUS: Only checks if the user owns the order,
        # not if the order status is actually 'paid'.
        try:
             order = Order.objects.get(pk=order_id, user=request.user)
             # MISSING CHECK: if order.status != 'paid': return redirect('payment_step', order_id=order.id)
             return render(request, 'confirmation.html', {'order': order})
        except Order.DoesNotExist:
             raise Http404
    ```

    #### Mitigation and Best Practices
    * Re-validate all conditions, prices, discounts, and eligibility server-side *at the point of final action* (e.g., checkout, order placement).
    * Enforce strict state transitions (e.g., use a state machine pattern). Check the object's current state before allowing the next step in a workflow.

    #### Secure Code Example
    ```python
    # views/checkout.py (Secure Discount)
    from django.contrib import messages

    @login_required
    def process_checkout_secure(request):
        discount_code = request.session.get('discount_code')
        cart_total = calculate_cart_total(request.user)
        final_total = cart_total

        if discount_code:
            # SECURE: Re-validate discount code validity *at checkout time*.
            is_valid, discount_amount = check_and_use_discount(discount_code, request.user, cart_total)
            if is_valid:
                final_total -= discount_amount
            else:
                 messages.warning(request, "Discount code is no longer valid.")
                 del request.session['discount_code']

        charge_user(request.user, final_total)
        if 'discount_code' in request.session: del request.session['discount_code']
        return HttpResponse("Checked out!")

    # views/order.py (Secure Confirmation Step)
    @login_required
    def confirmation_step_secure(request, order_id):
        try:
             order = Order.objects.get(pk=order_id, user=request.user)
             # SECURE: Check the authoritative state from the database.
             if order.status != 'paid':
                  messages.error(request, "Order payment not completed.")
                  return redirect('order_payment', order_id=order.id)
             return render(request, 'confirmation.html', {'order': order})
        except Order.DoesNotExist:
             raise Http404
    ```

    #### Testing Strategy
    Thoroughly map out application workflows. For each step, identify the required state and data. Attempt to:
    * Skip steps (e.g., browse directly to later URLs).
    * Replay requests for actions that should only happen once (e.g., submitting payment multiple times).
    * Manipulate parameters to trigger edge cases (e.g., negative quantities, future dates).
    * Perform actions out of sequence or when prerequisites aren't met (e.g., apply expired discount).
  </Tab>
  <Tab title="Java">
    #### Framework Context
    Flaws in Controllers or Services that don't correctly manage state transitions or re-validate business rules.

    #### Vulnerable Scenario 1: Price Check Only on Add-to-Cart
    The price of an item is checked when added to the cart, but not re-checked at checkout.
    ```java
    // service/CartService.java
    public void addToCart(String userId, String productId, int quantity) {
        Product p = productRepo.findById(productId).orElseThrow();
        // Price is correct when added
        cartRepo.addItem(userId, productId, quantity, p.getPrice());
    }

    // controller/CheckoutController.java
    @PostMapping("/checkout")
    public String checkout(Principal principal) {
        String userId = principal.getName();
        Cart cart = cartRepo.findByUserId(userId);
        BigDecimal total = BigDecimal.ZERO;
        // DANGEROUS: Calculates total based on prices stored in the cart
        // *when items were added*. Prices might have changed since then.
        for (CartItem item : cart.getItems()) {
            total = total.add(item.getPriceAtAddition().multiply(BigDecimal.valueOf(item.getQuantity())));
        }
        paymentService.charge(userId, total); // Charges potentially outdated total
        return "confirmation";
    }
    ```

    #### Vulnerable Scenario 2: Workflow Bypass via Parameter Manipulation
    An approval workflow requires manager approval, but the "approve" endpoint accepts an `isManagerApproved=true` parameter that the server trusts.
    ```java
    // controller/WorkflowController.java
    import org.springframework.security.access.prepost.PreAuthorize;
    import org.springframework.web.bind.annotation.*;
    import java.security.Principal;

    @PostMapping("/submit-request")
    public String submitRequest(@ModelAttribute RequestData data, Principal principal) {
        workflowService.createRequest(data, principal.getName());
        return "redirect:/requests";
    }

    @PostMapping("/approve-request/{id}")
    @PreAuthorize("hasRole('MANAGER')")
    public String approveRequest(@PathVariable long id, @RequestParam(required=false, defaultValue="false") boolean forceApprove) {
        // DANGEROUS: A manager calls this, but if 'forceApprove=true' is submitted
        // it bypasses normal checks. The logic flaw is trusting this flag.
        WorkflowRequest req = workflowRepo.findById(id).orElseThrow();
        if (forceApprove || workflowService.checkApprovalConditions(req)) {
            req.setStatus("APPROVED");
            workflowRepo.save(req);
        }
        return "redirect:/requests";
    }
    ```

    #### Mitigation and Best Practices
    * **Data Freshness:** Always retrieve authoritative data (prices, stock levels, user roles) from the database immediately before performing critical actions.
    * **Server Authority:** Do not trust parameters submitted by the client to indicate state or bypass checks (`forceApprove`). Re-evaluate all conditions server-side.
    * **State Enforcement:** Explicitly check the current state of an object before allowing state transitions.

    #### Secure Code Example
    ```java
    // controller/CheckoutController.java (Secure Price Check)
    @PostMapping("/checkout-secure")
    public String checkoutSecure(Principal principal) {
        String userId = principal.getName();
        Cart cart = cartRepo.findByUserId(userId);
        BigDecimal authoritativeTotal = BigDecimal.ZERO;

        // SECURE: Iterate cart items but fetch CURRENT price from product DB.
        for (CartItem item : cart.getItems()) {
            Product currentProduct = productRepo.findById(item.getProductId()).orElseThrow();
            authoritativeTotal = authoritativeTotal.add(
                currentProduct.getPrice().multiply(BigDecimal.valueOf(item.getQuantity()))
            );
        }
        paymentService.charge(userId, authoritativeTotal); // Charges correct, current total
        return "confirmation";
    }

    // controller/WorkflowController.java (Secure Approval)
    @PostMapping("/approve-request-secure/{id}")
    @PreAuthorize("hasRole('MANAGER')")
    public String approveRequestSecure(@PathVariable long id) { // forceApprove param removed
        WorkflowRequest req = workflowRepo.findById(id).orElseThrow();
        
        // SECURE: Always re-validate conditions on the server.
        if (workflowService.checkApprovalConditions(req)) {
            req.setStatus("APPROVED");
            workflowRepo.save(req);
        } else {
             return "redirect:/requests?error=conditions_not_met";
        }
        return "redirect:/requests";
    }
    ```

    #### Testing Strategy
    Map application workflows. Identify key data and state checks.
    * **Stale Data:** Add an item to cart, wait (simulate price change), checkout. Does it use the old or new price?
    * **State Bypass:** Try accessing step 3 URL before completing step 2.
    * **Parameter Tampering:** Modify hidden fields or parameters related to workflow state or conditions (`isApproved`, `status`, `forceApprove`) and see if the server accepts them.
    * **Race Conditions:** Submit duplicate requests rapidly for actions that should only occur once.
  </Tab>
  <Tab title=".NET(C#)">
    #### Framework Context
    Flaws in Controller Actions or PageModel Handlers not correctly validating state or business rules before executing actions.

    #### Vulnerable Scenario 1: Re-using a One-Time Token
    A password reset link uses a token, but the token isn't invalidated after the first successful use.
    ```csharp
    // Controllers/AccountController.cs
    [HttpPost("reset-password")]
    public async Task<IActionResult> ResetPassword(ResetPasswordViewModel model)
    {
        var user = await _context.Users.FirstOrDefaultAsync(u => u.PasswordResetToken == model.Token);
        if (user != null && user.PasswordResetTokenExpiry > DateTime.UtcNow)
        {
            // DANGEROUS: Token is checked, but not invalidated after use.
            // Attacker can reuse the token until it expires.
            await _userManager.ResetPasswordAsync(user, model.Token, model.NewPassword);
            
            // FORGOTTEN STEP:
            // user.PasswordResetToken = null;
            // user.PasswordResetTokenExpiry = null;
            // await _context.SaveChangesAsync();

            return RedirectToAction("ResetSuccess");
        }
        return View(model);
    }
    ```

    #### Vulnerable Scenario 2: Modifying Quantity Below Minimum Order
    Business rule requires minimum order quantity of 5, enforced client-side only.
    ```csharp
    // Pages/ProductPage.cshtml.cs
    public class ProductPageModel : PageModel
    {
        [BindProperty]
        public int InputQuantity { get; set;}
        [BindProperty]
        public int ProductId { get; set;}
        // ...
        public async Task<IActionResult> OnPostAsync()
        {
            // DANGEROUS: Server trusts the submitted quantity.
            // Attacker uses dev tools to change quantity to 1 before submitting.
            // Business rule (min 5) is bypassed because it's only checked client-side.
            if (InputQuantity <= 0) return BadRequest(); // Basic check, not business rule

            var product = await _context.Products.FindAsync(ProductId);
            _cartService.AddItem(product, InputQuantity); // Adds only 1 item
            return RedirectToPage("/Cart");
        }
    }
    ```

    #### Mitigation and Best Practices
    * **State Management:** Ensure state transitions are atomic. Invalidate tokens immediately after use (Identity's default `ResetPasswordAsync` does this).
    * **Server-Side Validation:** Re-validate all business rules (minimum quantities, etc.) on the server using data annotations (`[Range]`) or explicit checks in the action.

    #### Secure Code Example
    ```csharp
    // Controllers/AccountController.cs (Secure Token Invalidation)
    [HttpPost("reset-password")]
    public async Task<IActionResult> ResetPassword(ResetPasswordViewModel model)
    {
        var user = await _userManager.FindByEmailAsync(model.Email); // Find user by email
        if (user != null)
        {
            // SECURE: ResetPasswordAsync validates AND invalidates the token.
            var result = await _userManager.ResetPasswordAsync(user, model.Token, model.NewPassword);
            if (result.Succeeded)
            {
                // No need to manually nullify token; provider handles it.
                return RedirectToAction("ResetSuccess");
            }
            // ... handle errors ...
        }
        // ... handle user not found (generic message) ...
        return View(model);
    }

    // Pages/ProductPage.cshtml.cs (Secure Quantity Check)
    public class ProductPageModelSecure : PageModel
    {
        [BindProperty]
        public int ProductId { get; set;}
        
        // SECURE: Apply Range validation attribute server-side.
        [BindProperty]
        [Range(5, 100, ErrorMessage = "Quantity must be between 5 and 100.")]
        public int InputQuantity { get; set;}
        // ...
        public async Task<IActionResult> OnPostAsync()
        {
            // SECURE: ModelState.IsValid checks the [Range] attribute.
            if (!ModelState.IsValid)
            {
                // Reload product info for the page model if needed for display
                // Product = await _context.Products.FindAsync(ProductId);
                return Page(); // Return page with validation errors
            }

            var product = await _context.Products.FindAsync(ProductId);
            _cartService.AddItem(product, InputQuantity); // Adds valid quantity
            return RedirectToPage("/Cart");
        }
    }
    ```

    #### Testing Strategy
    Map workflows.
    * **Token Reuse:** Try using a password reset or email verification link multiple times.
    * **State Bypass:** Try accessing URLs or submitting forms for later steps before completing earlier ones.
    * **Business Rule Bypass:** Modify client-side values (quantities, amounts) to violate known business rules (minimums, maximums) and submit. Verify the server catches the violation (check `ModelState.IsValid`).
  </Tab>
  <Tab title="PHP">
    #### Framework Context
    Flaws in Controller logic or Services that fail to validate state transitions or business rules.

    #### Vulnerable Scenario 1: Applying Coupon Multiple Times
    A coupon can be applied, reducing the cart total, but there's no check to prevent applying it repeatedly.
    ```php
    // app/Http/Controllers/CartController.php
    use Illuminate\Http\Request;
    use App\Models\Coupon;
    use Illuminate\Support\Facades\Redirect;

    public function applyCoupon(Request $request) {
        $couponCode = $request->input('coupon_code');
        $coupon = Coupon::where('code', $couponCode)->first();

        if ($coupon && $coupon->isValid()) {
            $cart = $request->session()->get('cart');
            if ($cart) {
                 $cart->applyDiscount($coupon->discount_amount);
                 // DANGEROUS: Doesn't prevent applying the same (or different) coupon again.
                 $request->session()->put('cart', $cart);
                 session()->flash('message', 'Coupon applied!');
            } else {
                 session()->flash('error', 'Cart not found.');
            }
        } else {
            session()->flash('error', 'Invalid coupon code.');
        }
        return Redirect::route('cart.show');
    }
    ```

    #### Vulnerable Scenario 2: Bypassing Survey Completion for Reward
    Users get a reward after completing a survey, but the reward endpoint only checks if the survey *exists*, not if it's *completed*.
    ```php
    // app/Http/Controllers/SurveyController.php
    use App\Models\Survey;
    use Illuminate\Http\Request;
    use Illuminate\Support\Facades\Redirect;

    public function claimReward(Request $request, Survey $survey) {
        $user = auth()->user();

        // DANGEROUS: Only checks if user owns the survey record.
        // Doesn't check survey->is_completed flag or similar status.
        if ($survey->user_id !== $user->id) { abort(403); }

        // Give reward without checking completion status
        $user->addRewardPoints(100); // Assumes this method exists
        $survey->reward_claimed = true;
        $survey->save();

        return Redirect::route('rewards.index');
    }
    ```

    #### Mitigation and Best Practices
    * **State Tracking:** Add flags or status fields to models (e.g., `coupon_applied_to_cart_id`, `survey_completed_at`, `reward_claimed_at`) and check these flags before allowing actions.
    * **Re-validation at Critical Points:** Re-verify coupon validity, eligibility, and single-use constraints during the final checkout process. Check survey completion status before granting rewards.

    #### Secure Code Example
    ```php
    // app/Http/Controllers/CartController.php (Secure Coupon Application)
    public function applyCoupon(Request $request) {
        $couponCode = $request->input('coupon_code');
        $coupon = Coupon::where('code', $couponCode)->first();
        $cart = $request->session()->get('cart');

        if (!$cart) {
             session()->flash('error', 'Cart not found.');
             return Redirect::route('cart.show');
        }

        // SECURE: Check if a coupon is already applied to this cart.
        if ($cart->coupon_applied_id !== null) {
            session()->flash('error', 'Only one coupon per order.');
            return Redirect::route('cart.show');
        }

        if ($coupon && $coupon->isValidForCart($cart)) {
            $cart->applyDiscount($coupon->discount_amount);
            $cart->coupon_applied_id = $coupon->id; // Mark coupon as applied
            $request->session()->put('cart', $cart);
            session()->flash('message', 'Coupon applied!');
        } else {
            session()->flash('error', 'Invalid or inapplicable coupon code.');
        }
        return Redirect::route('cart.show');
    }

    // app/Http/Controllers/SurveyController.php (Secure Reward Claim)
    public function claimReward(Request $request, Survey $survey) {
        $user = auth()->user();
        if ($survey->user_id !== $user->id) { abort(403); }

        // SECURE: Check survey completion status.
        if (!$survey->is_completed) { // Assume is_completed is a boolean field
             session()->flash('error', 'Survey not completed yet.');
             return Redirect::route('survey.show', $survey);
        }
        // SECURE: Check if reward already claimed.
        if ($survey->reward_claimed) {
            session()->flash('error', 'Reward already claimed for this survey.');
            return Redirect::route('rewards.index');
        }

        // Give reward only if checks pass
        $user->addRewardPoints(100);
        $survey->reward_claimed = true;
        $survey->save();

        return Redirect::route('rewards.index');
    }
    ```

    #### Testing Strategy
    Map application workflows.
    * **Replay Actions:** Try applying a coupon twice. Try claiming a reward twice.
    * **State Bypass:** Access reward URL before completing the survey.
    * **Concurrency:** Use tools (Burp Intruder) to submit multiple requests simultaneously (e.g., two requests to use a single-use coupon). Verify only one succeeds.
    Manual testing and careful code review are crucial.
  </Tab>
  <Tab title="Node.js">
    #### Framework Context
    Flaws in Express route handlers or service logic that fail to manage state transitions correctly or re-verify business rules.

    #### Vulnerable Scenario 1: Voting Multiple Times
    An API endpoint allows voting but doesn't implement atomicity, leading to race conditions.
    ```javascript
    // routes/poll.js
    router.post('/:pollId/vote', ensureAuthenticated, async (req, res) => {
        const { pollId } = req.params;
        const { optionId } = req.body;
        const userId = req.user.id;

        try {
            // DANGEROUS: Race condition. Attacker sends 10 requests at once.
            // All 10 requests might pass this check before any vote is saved.
            const hasVoted = await VoteService.checkIfUserVoted(userId, pollId);
            if (hasVoted) {
                return res.status(400).send('Already voted.');
            }

            // Record the vote
            await VoteService.recordVote(userId, pollId, optionId);
            res.send('Vote recorded.');
        } catch (err) { res.status(500).send('Error.'); }
    });
    ```

    #### Vulnerable Scenario 2: Adding Item After Order Finalized
    An endpoint to add items to a cart doesn't check if the cart/order has already been submitted or paid for.
    ```javascript
    // routes/cart.js
    router.post('/items', ensureAuthenticated, async (req, res) => {
        const { cartId, productId, quantity } = req.body;
        const userId = req.user.id;

        try {
             // DANGEROUS: Fetches cart but doesn't check its status.
             // Attacker could submit this request *after* payment for 'cartId' is complete.
             const cart = await CartService.getCart(cartId, userId);
             if (!cart) return res.status(404).send('Cart not found.');

             // Logic proceeds even if cart.status is 'PAID' or 'SUBMITTED'
             await CartService.addItem(cartId, productId, quantity);
             res.send('Item added.');

        } catch (err) { res.status(500).send('Error.'); }
    });
    ```

    #### Mitigation and Best Practices
    * **Atomicity/Locking:** Use database transactions with locking (`SELECT ... FOR UPDATE`) or atomic operations (`findOneAndUpdate` with conditions) to prevent race conditions. Use unique constraints in the database (e.g., on `(userId, pollId)` for votes).
    * **State Validation:** Always check the current state of the object (`cart.status`) before performing an action.

    #### Secure Code Example
    ```javascript
    // routes/poll.js (Secure - using DB constraints or atomic update)
    router.post('/:pollId/vote-secure', ensureAuthenticated, async (req, res) => {
        // ... params ...
        try {
            // SECURE: Attempt to record vote using a method that includes atomicity.
            // This method should rely on a unique DB constraint (userId, pollId).
            const voteRecorded = await VoteService.recordVoteAtomically(userId, pollId, optionId);

            if (voteRecorded) { // true if insert succeeded
                res.send('Vote recorded.');
            } else { // false if insert failed (e.g., unique constraint violation)
                res.status(400).send('Already voted.');
            }
        } catch (err) {
             // Handle DB errors (like constraint violation if not caught by service)
             res.status(500).send('Error recording vote.');
        }
    });

    // routes/cart.js (Secure - Check Status)
    router.post('/items-secure', ensureAuthenticated, async (req, res) => {
        // ... params ...
        try {
             const cart = await CartService.getCart(cartId, userId);
             if (!cart) return res.status(404).send('Cart not found.');

             // SECURE: Check the cart's status before allowing modification.
             if (cart.status !== 'ACTIVE') {
                  return res.status(400).send('Cart is not active and cannot be modified.');
             }

             await CartService.addItem(cartId, productId, quantity);
             res.send('Item added.');

        } catch (err) { res.status(500).send('Error.'); }
    });
    ```

    #### Testing Strategy
    Map workflows.
    * **Race Conditions:** Use an intercepting proxy (Burp Intruder) to send multiple identical requests (e.g., to vote) nearly simultaneously. Check if the action is performed more than once.
    * **State Bypass:** Identify objects with status fields (Cart, Order, Survey). Try performing actions only valid for one status when the object is in a different status (e.g., add item to 'PAID' cart).
  </Tab>
  <Tab title="Ruby">
    #### Framework Context
    Flaws in Controller actions or Models that don't enforce state transitions or re-verify business conditions.

    #### Vulnerable Scenario 1: Transferring More Funds Than Available
    A bank transfer function checks the balance initially but doesn't use locking, allowing a race condition.
    ```ruby
    # app/controllers/transfers_controller.rb
    class TransfersController < ApplicationController
      def create
        amount = BigDecimal(params[:amount])
        recipient = User.find(params[:recipient_id])
        sender = current_user

        # DANGEROUS: Balance checked outside of transaction lock.
        if sender.balance >= amount && amount > 0
          # Attacker sends two simultaneous requests for $100 when balance is $100.
          # Both might pass this check before either transaction completes.
          ActiveRecord::Base.transaction do
            sender.balance -= amount
            recipient.balance += amount
            sender.save!
            recipient.save!
          end
          redirect_to root_path, notice: "Transfer successful."
        else
          redirect_to root_path, alert: "Insufficient funds or invalid amount."
        end
      end
    end
    ```

    #### Vulnerable Scenario 2: Modifying Finalized Record
    Allowing edits to an invoice after it has been marked as 'paid'.
    ```ruby
    # app/controllers/invoices_controller.rb
    class InvoicesController < ApplicationController
      before_action :set_invoice

      def update
        # DANGEROUS: Does not check invoice status before allowing update.
        # Attacker could change items/amount on an already paid invoice.
        if @invoice.update(invoice_params)
           redirect_to @invoice, notice: 'Invoice updated.'
        else
           render :edit
        end
      end

      private
      def set_invoice
        @invoice = current_user.invoices.find(params[:id])
      end
    end
    ```

    #### Mitigation and Best Practices
    * **Locking/Atomicity:** Use pessimistic locking (`sender.lock!`) within the transaction to prevent race conditions during balance checks and updates.
    * **State Validation:** Check the object's state *before* performing actions (`unless @invoice.is_editable? ...`). Use state machine gems (`aasm`) to enforce valid transitions.

    #### Secure Code Example
    ```ruby
    # app/controllers/transfers_controller.rb (Secure - Pessimistic Locking)
    class TransfersController < ApplicationController
      def create
        amount = BigDecimal(params[:amount])
        recipient = User.find(params[:recipient_id])
        sender = current_user

        # SECURE: Perform check and update within a transaction with locking.
        ActiveRecord::Base.transaction do
          sender.lock! # Lock the sender row
          recipient.lock! # Lock the recipient row

          # Re-check balance *after* acquiring lock
          if sender.balance >= amount && amount > 0
            sender.balance -= amount
            recipient.balance += amount
            sender.save!
            recipient.save!
          else
            raise ActiveRecord::Rollback, "Insufficient funds or invalid amount."
          end
        end
        redirect_to root_path, notice: "Transfer successful."
      rescue ActiveRecord::Rollback => e
        redirect_to root_path, alert: e.message
      end
    end

    # app/controllers/invoices_controller.rb (Secure - State Check)
    class InvoicesController < ApplicationController
      before_action :set_invoice
      before_action :check_if_editable, only: [:edit, :update]

      def update
        if @invoice.update(invoice_params)
           redirect_to @invoice, notice: 'Invoice updated.'
        else
           render :edit, status: :unprocessable_entity
        end
      end

      private
      def set_invoice
        @invoice = current_user.invoices.find(params[:id])
      end

      def check_if_editable
        # Assume Invoice model has statuses like 'draft', 'sent', 'paid'
        unless @invoice.status == 'draft'
           redirect_to @invoice, alert: "Cannot edit an invoice that is not in draft status."
        end
      end
    end
    ```

    #### Testing Strategy
    Map workflows.
    * **Race Conditions:** Use tools (Burp Intruder) to send simultaneous requests for balance-dependent actions. Verify only one succeeds or balance remains correct.
    * **State Bypass:** Attempt to perform actions on objects in the wrong state (e.g., edit a 'paid' invoice). Verify the action is denied based on server-side state checks (`before_action`, model validations, state machine).
  </Tab>
</Tabs>